{
  "JacksonDatabind-54": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `buildWriter` function is not correctly handling the case where the inclusion rule is set to `NON_ABSENT` and the property has a default value of null. In this case, the function should suppress the null value and not include it in the serialized output. However, the current implementation is not doing so, resulting in the incorrect output.\nSuggestion: Modify Inclusion Rule Handling\nWe can modify the `buildWriter` function to correctly handle the case where the inclusion rule is set to `NON_ABSENT` and the property has a default value of null. We can add a check for this case and suppress the null value if necessary. Here's an example of how the modified code could look:\n```java\nif (inclusion == JsonInclude.Include.NON_ABSENT && valueToSuppress == null) {\n    suppressNulls = true;\n}\n```\nThis change would ensure that the null value is suppressed when the inclusion rule is set to `NON_ABSENT`.\n// Buggy Function\nprotected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (declaredType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `buildWriter` function is not correctly handling the case where the inclusion rule is set to `NON_ABSENT` and the property has a default value of null. In this case, the function should suppress the null value and not include it in the serialized output. However, the current implementation is not doing so, resulting in the incorrect output.\nSuggestion: Use a Different Default Value\nAnother potential fix is to use a different default value for the property when the inclusion rule is set to `NON_ABSENT`. For example, we could use an empty string or an empty collection instead of null. This would ensure that the property is not included in the serialized output when it has a default value of null. Here's an example of how the modified code could look:\n```java\nif (inclusion == JsonInclude.Include.NON_ABSENT) {\n    valueToSuppress = \"\";\n}\n```\nThis change would ensure that the property is not included in the serialized output when it has a default value of null.\n// Buggy Function\nprotected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (declaredType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `buildWriter` function is not correctly handling the case where the inclusion rule is set to `NON_ABSENT` and the property has a default value of null. In this case, the function should suppress the null value and not include it in the serialized output. However, the current implementation is not doing so, resulting in the incorrect output.\nSuggestion: Modify the `getPropertyDefaultValue` Method\nWe can also modify the `getPropertyDefaultValue` method to return a different default value when the inclusion rule is set to `NON_ABSENT`. For example, we could return an empty string or an empty collection instead of null. This would ensure that the property is not included in the serialized output when it has a default value of null. Here's an example of how the modified code could look:\n```java\npublic Object getPropertyDefaultValue(String propertyName, AnnotatedMember member, JavaType type) {\n    if (inclusion == JsonInclude.Include.NON_ABSENT) {\n        return \"\";\n    }\n    // ... rest of the method remains the same ...\n}\n```\nThis change would ensure that the property is not included in the serialized output when it has a default value of null.\n// Buggy Function\nprotected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (declaredType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (valueToSuppress != null && declaredType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
      "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // Retrieve the default value for the property to correctly suppress when value is default (including null)\n        valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
      "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // get the default value to determine suppression\n        valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        // for reference types with default null, use marker for emptiness\n        if (valueToSuppress == null && declaredType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}"
    ]
  }
}