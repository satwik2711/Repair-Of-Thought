{
  "Jsoup-76": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of this bug is that the parser is not correctly handling the 'pre' tag and its content. Specifically, the parser is not skipping the first newline character as expected. This is likely due to a logic error in the parser's handling of the 'pre' tag.\nSuggestion: Modify Pre Tag Handling\nWe can modify the parser's handling of the 'pre' tag to correctly skip the first newline character. We can add a check for the 'pre' tag and skip the first newline character if it is present. This can be done by adding a conditional statement to check for the 'pre' tag and then skipping the first newline character if it is present.\n\n```java\n// Add a check for the 'pre' tag and skip the first newline character\nif (name.equals(\"pre\")) {\n    // Skip the first newline character\n    if (tb.framesetOk() && isWhitespace(c)) {\n        tb.reconstructFormattingElements();\n        tb.insert(c);\n    } else {\n        tb.reconstructFormattingElements();\n        tb.insert(c);\n        tb.framesetOk(false);\n    }\n}\n```\n// Buggy Function\nboolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            // todo - refactor to a switch statement\n            String name = startTag.normalName();\n            if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.processEndTag(\"a\");\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"span\")) {\n                // same as final else, but short circuits lots of checks\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.processEndTag(\"li\");\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().get(0);\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.remove(stack.size()-1);\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertForm(startTag, true);\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                        tb.processEndTag(el.nodeName());\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.processEndTag(\"button\");\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.processEndTag(\"nobr\");\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                if (tb.getFromStack(\"svg\") == null)\n                    return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                else\n                    tb.insert(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.processStartTag(\"form\");\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.processStartTag(\"hr\");\n                tb.processStartTag(\"label\");\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character().data(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.processStartTag(\"input\", inputAttribs);\n                tb.processEndTag(\"label\");\n                tb.processStartTag(\"hr\");\n                tb.processEndTag(\"form\");\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.processEndTag(\"option\");\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.normalName();\n            if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                // Adoption Agency Algorithm.\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    ArrayList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int stackSize = stack.size();\n                    for (int si = 0; si < stackSize && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue;\n                        } else if (node == formatEl)\n                            break;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                        // case will follow the original node (so honours ParseSettings)\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    adopter.attributes().addAll(formatEl.attributes());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"span\")) {\n                // same as final fall through, but saves short circuit\n                return anyOtherEndTag(t, tb);\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.processEndTag(\"body\");\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (!tb.inScope(Constants.Headings)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(Constants.Headings);\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.processStartTag(\"br\");\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of this bug is that the parser is not correctly handling the 'pre' tag and its content. Specifically, the parser is not skipping the first newline character as expected. This is likely due to a logic error in the parser's handling of the 'pre' tag.\nSuggestion: Use a Flag to Track Newline Characters\nWe can use a flag to track whether a newline character has been encountered while parsing the 'pre' tag. If a newline character is encountered, we can set the flag to true and then skip any subsequent newline characters. This can be done by adding a boolean flag to the parser and setting it to true when a newline character is encountered.\n\n```java\n// Add a flag to track newline characters\nboolean newlineEncountered = false;\n\n// ...\n\n// Check for newline characters and set the flag\nif (c.getData().equals(\"\\n\")) {\n    newlineEncountered = true;\n}\n\n// Skip newline characters if the flag is set\nif (newlineEncountered && c.getData().equals(\"\\n\")) {\n    // Skip the newline character\n}\n```\n// Buggy Function\nboolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            // todo - refactor to a switch statement\n            String name = startTag.normalName();\n            if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.processEndTag(\"a\");\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"span\")) {\n                // same as final else, but short circuits lots of checks\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.processEndTag(\"li\");\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().get(0);\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.remove(stack.size()-1);\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertForm(startTag, true);\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                        tb.processEndTag(el.nodeName());\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.processEndTag(\"button\");\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.processEndTag(\"nobr\");\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                if (tb.getFromStack(\"svg\") == null)\n                    return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                else\n                    tb.insert(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.processStartTag(\"form\");\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.processStartTag(\"hr\");\n                tb.processStartTag(\"label\");\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character().data(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.processStartTag(\"input\", inputAttribs);\n                tb.processEndTag(\"label\");\n                tb.processStartTag(\"hr\");\n                tb.processEndTag(\"form\");\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.processEndTag(\"option\");\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.normalName();\n            if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                // Adoption Agency Algorithm.\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    ArrayList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int stackSize = stack.size();\n                    for (int si = 0; si < stackSize && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue;\n                        } else if (node == formatEl)\n                            break;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                        // case will follow the original node (so honours ParseSettings)\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    adopter.attributes().addAll(formatEl.attributes());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"span\")) {\n                // same as final fall through, but saves short circuit\n                return anyOtherEndTag(t, tb);\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.processEndTag(\"body\");\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (!tb.inScope(Constants.Headings)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(Constants.Headings);\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.processStartTag(\"br\");\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of this bug is that the parser is not correctly handling the 'pre' tag and its content. Specifically, the parser is not skipping the first newline character as expected. This is likely due to a logic error in the parser's handling of the 'pre' tag.\nSuggestion: Modify the Parser's State Machine\nWe can modify the parser's state machine to correctly handle the 'pre' tag and skip the first newline character. We can add a new state to the state machine that specifically handles the 'pre' tag and skips the first newline character. This can be done by adding a new state to the state machine and modifying the transitions between states.\n\n```java\n// Add a new state to the state machine\nenum State {\n    // ...\n    PRE_TAG,\n    // ...\n}\n\n// Modify the transitions between states\nswitch (state) {\n    // ...\n    case PRE_TAG:\n        // Skip the first newline character\n        if (c.getData().equals(\"\\n\")) {\n            // Skip the newline character\n        }\n        break;\n    // ...\n}\n```\n// Buggy Function\nboolean process(Token t, HtmlTreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                // todo confirm that check\n                tb.error(this);\n                return false;\n            } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            // todo - refactor to a switch statement\n            String name = startTag.normalName();\n            if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.processEndTag(\"a\");\n\n                    // still on stack?\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"span\")) {\n                // same as final else, but short circuits lots of checks\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.processEndTag(\"li\");\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"html\")) {\n                tb.error(this);\n                // merge attributes onto real html\n                Element html = tb.getStack().get(0);\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                ArrayList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!tb.framesetOk()) {\n                    return false; // ignore frameset\n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    // pop up to html element\n                    while (stack.size() > 1)\n                        stack.remove(stack.size()-1);\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertForm(startTag, true);\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                tb.framesetOk(false);\n                ArrayList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                        tb.processEndTag(el.nodeName());\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    // close and reprocess\n                    tb.error(this);\n                    tb.processEndTag(\"button\");\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.processEndTag(\"nobr\");\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                if (tb.getFromStack(\"svg\") == null)\n                    return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                else\n                    tb.insert(startTag);\n            } else if (name.equals(\"isindex\")) {\n                // how much do we care about the early 90s?\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n\n                tb.processStartTag(\"form\");\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.processStartTag(\"hr\");\n                tb.processStartTag(\"label\");\n                // hope you like english.\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                tb.process(new Token.Character().data(prompt));\n\n                // input\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.processStartTag(\"input\", inputAttribs);\n                tb.processEndTag(\"label\");\n                tb.processStartTag(\"hr\");\n                tb.processEndTag(\"form\");\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.processEndTag(\"p\");\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                // also handle noscript if script enabled\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n\n                HtmlTreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.processEndTag(\"option\");\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                tb.insert(startTag);\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                tb.insert(startTag);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.normalName();\n            if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                // Adoption Agency Algorithm.\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    ArrayList<Element> stack = tb.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int stackSize = stack.size();\n                    for (int si = 0; si < stackSize && si < 64; si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                            tb.removeFromStack(node);\n                            continue;\n                        } else if (node == formatEl)\n                            break;\n\n                        Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                        // case will follow the original node (so honours ParseSettings)\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n\n                        if (lastNode == furthestBlock) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n\n                        lastNode = node;\n                    }\n\n                    if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n\n                    Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                    adopter.attributes().addAll(formatEl.attributes());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                if (!tb.inScope(name)) {\n                    // nothing to close\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"span\")) {\n                // same as final fall through, but saves short circuit\n                return anyOtherEndTag(t, tb);\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.processEndTag(\"body\");\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                if (!tb.inScope(Constants.Headings)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(Constants.Headings);\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                // *sigh*\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.processStartTag(\"br\");\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": []
  }
}