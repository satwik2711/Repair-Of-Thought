{
  "Closure-31": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `manageDependencies` method is not correctly sorting the dependencies in whitespace mode. The method is supposed to reorder the inputs based on their dependencies, but it is not doing so correctly, resulting in the incorrect ordering of the `goog.provide` and `goog.require` statements.\nSuggestion: Modify the manageDependencies Method to Use Topological Sorting\nThe `manageDependencies` method can be modified to use a topological sorting algorithm to ensure that the dependencies are correctly ordered in whitespace mode. This can be done by creating a graph data structure to represent the dependencies and then using a topological sorting algorithm to reorder the inputs. The modified method would first create a graph where each node represents an input and each edge represents a dependency between two inputs. Then, it would use a topological sorting algorithm to reorder the inputs based on their dependencies.\n// Buggy Function\nNode parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    // Check if inputs need to be rebuilt from modules.\n    boolean staleInputs = false;\n\n    // Check if the sources need to be re-ordered.\n    if (options.dependencyOptions.needsManagement() &&\n        !options.skipAllPasses &&\n        options.closurePass) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST during initial parse.\n      if (n == null) {\n        continue;\n      }\n\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          // If the input file is explicitly marked as an externs file, then\n          // assume the programmer made a mistake and throw it into\n          // the externs pile anyways.\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n\n          input.getModule().remove(input);\n\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `manageDependencies` method is not correctly sorting the dependencies in whitespace mode. The method is supposed to reorder the inputs based on their dependencies, but it is not doing so correctly, resulting in the incorrect ordering of the `goog.provide` and `goog.require` statements.\nSuggestion: Add a Special Case for Whitespace Mode in the manageDependencies Method\nA special case can be added to the `manageDependencies` method to handle whitespace mode. In this case, the method would check if the compilation level is set to WHITESPACE_ONLY and if so, use a different sorting algorithm or reorder the inputs manually. For example, it could use a simple sorting algorithm that reorders the inputs based on their dependencies, or it could use a more complex algorithm that takes into account the specific requirements of whitespace mode.\n// Buggy Function\nNode parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    // Check if inputs need to be rebuilt from modules.\n    boolean staleInputs = false;\n\n    // Check if the sources need to be re-ordered.\n    if (options.dependencyOptions.needsManagement() &&\n        !options.skipAllPasses &&\n        options.closurePass) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST during initial parse.\n      if (n == null) {\n        continue;\n      }\n\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          // If the input file is explicitly marked as an externs file, then\n          // assume the programmer made a mistake and throw it into\n          // the externs pile anyways.\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n\n          input.getModule().remove(input);\n\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `manageDependencies` method is not correctly sorting the dependencies in whitespace mode. The method is supposed to reorder the inputs based on their dependencies, but it is not doing so correctly, resulting in the incorrect ordering of the `goog.provide` and `goog.require` statements.\nSuggestion: Use a Dependency Graph to Represent Dependencies in the manageDependencies Method\nThe `manageDependencies` method can be modified to use a dependency graph to represent the dependencies between inputs. The graph would be created by iterating over the inputs and adding edges between nodes that represent dependencies. Then, the method would use a graph traversal algorithm to reorder the inputs based on their dependencies. This approach would ensure that the dependencies are correctly ordered in whitespace mode, and it would also provide a more efficient and scalable solution than the current implementation.\n// Buggy Function\nNode parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    // Check if inputs need to be rebuilt from modules.\n    boolean staleInputs = false;\n\n    // Check if the sources need to be re-ordered.\n    if (options.dependencyOptions.needsManagement() &&\n        !options.skipAllPasses &&\n        options.closurePass) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST during initial parse.\n      if (n == null) {\n        continue;\n      }\n\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          // If the input file is explicitly marked as an externs file, then\n          // assume the programmer made a mistake and throw it into\n          // the externs pile anyways.\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n\n          input.getModule().remove(input);\n\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "<think>\nOkay, so I need to fix the manageDependencies method because it's not correctly sorting dependencies in whitespace mode. The root cause is that the current method isn't using topological sorting, which is necessary for proper ordering of goog.provide and goog.require statements.\n\nFirst, I'll look at the existing code. The function parseInputs() is handling a lot of things, including parsing externs, managing dependencies, and building the AST. The problem lies in the manageDependencies method, which is part of the JSModuleGraph class, I think.\n\nThe suggestion is to modify manageDependencies to use topological sorting. So, I need to replace the current sorting logic with a topological sort. Topological sorting ensures that for every directed edge (u -> v), node u comes before v in the ordering. This is exactly what we need for dependencies.\n\nI should create a graph where each node represents a CompilerInput. Each edge represents a dependency from one input to another. Then, perform a topological sort on this graph to get the correct order.\n\nLet me think about how to implement this. I'll need to:\n\n1. Build a dependency graph. Each node is a CompilerInput. For each input, find all the inputs it depends on (i.e., the inputs that provide the modules it requires).\n\n2. Use a topological sorting algorithm on this graph. I can implement Kahn's algorithm, which is good for topological sorting. It uses in-degree counts and a queue to process nodes with zero in-degrees.\n\n3. Handle any circular dependencies by catching exceptions and reporting errors, as the original code does.\n\nSo, in the manageDependencies method, instead of the current sorting, I'll construct the graph and perform the topological sort.\n\nWait, but the original code is in the parseInputs function. Oh, no, the manageDependencies method is called on the moduleGraph. So, I need to modify that method in the JSModuleGraph class.\n\nWait, the user provided the parseInputs function, but the bug is in manageDependencies. So, perhaps the fixed function is the parseInputs function, but the actual fix is in the manageDependencies method. Hmm, the user's instruction is a bit confusing.\n\nWait, looking back, the user provided the buggy function as parseInputs(), and the fixed function is to be provided. But the root cause is in manageDependencies. So, perhaps the fixed code is within parseInputs(), where manageDependencies is called.\n\nWait, no. The parseInputs function is part of the compiler, and manageDependencies is a method called on moduleGraph. So, the fix is to change the manageDependencies method, but the user is asking to provide the corrected parseInputs function. Or perhaps the user is mistaken, and the fix is within parseInputs.\n\nWait, the user says: \"Produce a corrected, function-level implementation that fully addresses the identified bug.\" So, the function to fix is parseInputs(). But the bug is in manageDependencies, which is called inside parseInputs(). So, perhaps the fix is to modify how manageDependencies is used or implemented within parseInputs().\n\nWait, but manageDependencies is a method of JSModuleGraph. So, perhaps the fix involves changing that method. But since the user provided parseInputs(), maybe the fix is to adjust the way manageDependencies is called or to implement the topological sort within that method.\n\nAlternatively, perhaps the user wants the parseInputs function to be fixed, but the actual fix is elsewhere. Hmm.\n\nWait, the user's instruction says: \"Modify the manageDependencies Method to Use Topological Sorting.\" So, the fix is to change manageDependencies, but the function provided is parseInputs(). So, perhaps the user is asking to fix parseInputs() by ensuring that manageDependencies uses topological sorting.\n\nBut since I can't change manageDependencies directly here, perhaps the user expects me to adjust the code within parseInputs() to handle the dependencies correctly, perhaps by implementing the topological sort there.\n\nAlternatively, perhaps the user made a mistake and the function to fix is manageDependencies, but the initial code provided is parseInputs(). Hmm.\n\nWait, perhaps the user is asking to fix the parseInputs function by modifying how dependencies are managed, perhaps by implementing the topological sort within that function.\n\nAlternatively, perhaps the manageDependencies method is part of the same class as parseInputs(), and I can adjust it within the same code.\n\nBut given the context, the user provided the parseInputs function, and the bug is in manageDependencies. So, perhaps the fixed function will involve modifying the manageDependencies method.\n\nWait, but the user says to return the corrected parseInputs function. So, perhaps the fix is to adjust the code within parseInputs() where manageDependencies is called, perhaps by replacing that logic with a topological sort.\n\nAlternatively, perhaps the manageDependencies method is buggy and needs to be fixed, but since the user is asking for the parseInputs function, perhaps the fix is to replace the manageDependencies call with a custom topological sort.\n\nWait, perhaps the original code in parseInputs() calls manageDependencies, which is not correctly sorting. So, the fix is to replace that part with a topological sort.\n\nSo, in the parseInputs function, the code is:\n\ninputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(...)\n\nSo, perhaps the manageDependencies method is where the bug is, and the fix is to implement topological sorting there.\n\nBut since I can't change manageDependencies directly, perhaps the user expects me to modify the parseInputs function to include the topological sorting logic instead of relying on manageDependencies.\n\nAlternatively, perhaps the user is mistaken, and the fix is to correct the manageDependencies method, but the function to provide is parseInputs().\n\nHmm, this is a bit confusing. But given the instructions, I need to provide the corrected parseInputs function.\n\nSo, perhaps the approach is to replace the manageDependencies call with a topological sort within parseInputs().\n\nAlternatively, perhaps the manageDependencies method is supposed to perform the topological sort, but isn't, so I need to adjust it.\n\nBut given that the user provided the parseInputs function, perhaps the fix is to modify the manageDependencies method within that function.\n\nAlternatively, perhaps the parseInputs function is correct, and the bug is elsewhere.\n\nWait, perhaps the problem is that manageDependencies isn't correctly sorting, so the fix is to implement a topological sort in that method.\n\nBut since I can't see the manageDependencies code, perhaps the user expects me to adjust the parseInputs function to perform the topological sort.\n\nAlternatively, perhaps the user wants me to modify the manageDependencies method, but since the function to fix is parseInputs(), perhaps I need to adjust how manageDependencies is called or replace it with a custom sorting.\n\nHmm, perhaps the best approach is to implement the topological sort within the parseInputs function, replacing the manageDependencies call.\n\nSo, in the code, where it says:\n\ninputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);\n\nI can replace this with a topological sort.\n\nSo, I'll need to:\n\n1. Build a dependency graph where each node is a CompilerInput, and edges represent dependencies.\n\n2. Perform a topological sort on this graph.\n\n3. Reorder the inputs accordingly.\n\nSo, let's outline the steps within parseInputs().\n\nFirst, after the for loop that adds provides, I'll check if dependency management is needed.\n\nThen, instead of calling manageDependencies, I'll build the graph.\n\nEach input has provides and requires. So, for each input, I'll find all other inputs that provide the modules it requires.\n\nSo, for each input in inputs, for each of its requires, find the input that provides it, and add a dependency.\n\nOnce the graph is built, perform topological sort.\n\nImplementing Kahn's algorithm:\n\n- Compute in-degrees for each node.\n\n- Use a queue to process nodes with in-degree zero.\n\n- For each node processed, reduce the in-degree of its dependents.\n\n- Add nodes to the sorted list in the order they're processed.\n\nIf a cycle is detected (queue is empty but there are nodes left), throw a CircularDependencyException.\n\nSo, in code:\n\n- Create a map from provides to inputs. Because each input can provide multiple modules, but each module is provided by exactly one input in the final graph.\n\nWait, but in the code, each input has a set of provides. So, for each module name, there should be only one input providing it, otherwise, it's an error.\n\nSo, I can create a map: providedModuleToInput.\n\nThen, for each input, for each of its requires, find the input that provides it, and add an edge from the current input to the providing input.\n\nWait, no. Because if input A requires module M, which is provided by input B, then A depends on B. So, in the graph, B should come before A. So, the edge should be from B to A, indicating that B must be processed before A.\n\nWait, no. Wait, in topological sorting, if A depends on B, then B must come before A. So, in the graph, A has an edge to B, indicating that A depends on B. Or is it the other way around?\n\nWait, no. Let me think: If A depends on B, then B must be processed before A. So, in the graph, B is a prerequisite for A. So, the edge should be from B to A, indicating that B must come before A. Or is it the other way around?\n\nWait, no. In a dependency graph, an edge from A to B indicates that A depends on B, so B must come before A. So, when building the graph, for each require in A, find the input B that provides it, and add an edge from A to B. Then, during topological sort, B comes before A.\n\nWait, no, that's the opposite. Let me clarify:\n\nIf A requires B, then B must be loaded before A. So, in the graph, A depends on B, so we draw an edge from A to B. Then, during topological sorting, B comes before A.\n\nWait, no. Because in Kahn's algorithm, you start with nodes that have no incoming edges (in-degree zero). So, if B has no dependencies, it can be processed first. Then, when B is processed, it removes edges to its dependents, reducing their in-degree.\n\nSo, in the graph, edges go from dependencies to dependents. So, if A depends on B, then B is a dependency of A, so the edge is from B to A. Because B must come before A.\n\nWait, no. Let me think again. Suppose A depends on B. So, B must be processed before A. So, in the graph, A has an edge pointing to B, indicating that A depends on B. Or is it the other way around?\n\nNo, that's not correct. Because in a dependency graph, edges represent dependencies. So, if A depends on B, then B is a prerequisite for A. So, the edge should be from A to B, indicating that A depends on B. But in topological sorting, we want to process B before A. So, in the graph, the edge should be from B to A, because B must come before A.\n\nWait, I'm getting confused. Let me look up Kahn's algorithm.\n\nIn Kahn's algorithm, you process nodes with in-degree zero. Each time you process a node, you reduce the in-degree of its neighbors. So, the edges represent dependencies: if there's an edge from A to B, then A must come before B. So, B depends on A.\n\nWait, no. If A must come before B, then the edge is from A to B, meaning A is a prerequisite for B. So, when you process A, you can then process B.\n\nSo, in our case, if input A requires module M, which is provided by input B, then A depends on B. So, B must come before A. So, the edge should be from B to A, indicating that B is a dependency of A.\n\nWait, no. Because if A depends on B, then B must come before A. So, in the graph, the edge is from A to B, meaning A depends on B. So, when building the graph, for each require in A, find B (the provider), and add an edge from A to B. Then, during topological sort, B will be processed before A.\n\nWait, no. Because if A has an edge to B, that means A depends on B, so B must come before A. So, in the graph, the edge is from A to B, indicating that A depends on B. So, during topological sorting, B is processed before A.\n\nSo, in code:\n\nFor each input in inputs:\n    for each required module in input.getRequires():\n        find the input that provides this module (providerInput)\n        add an edge from current input to providerInput\n\nWait, no. Because if current input requires providerInput's module, then providerInput must come before current input. So, the edge should be from providerInput to current input, indicating that providerInput is a dependency of current input.\n\nWait, I'm getting stuck here. Let me think differently.\n\nEach edge represents a dependency: if A depends on B, then B must come before A. So, the edge should be from B to A, because B is a prerequisite for A.\n\nSo, in code:\n\nfor each input in inputs:\n    for each requiredModule in input.getRequires():\n        providerInput = providedModuleToInput.get(requiredModule)\n        if (providerInput != null) {\n            add an edge from providerInput to input\n        }\n\nThis way, providerInput must come before input.\n\nSo, in the graph, edges go from provider to dependent.\n\nThus, when performing topological sort, provider inputs are processed before the dependents.\n\nSo, in the code, I'll need to:\n\n1. Create a map from provided modules to inputs. So, for each input, for each provide in input.getProvides(), add an entry to the map.\n\nBut wait, each module can be provided by only one input. So, if multiple inputs provide the same module, it's an error.\n\nSo, I'll need to check that each module is provided by at most one input.\n\nSo, in code:\n\nMap<String, CompilerInput> providedModuleToInput = new HashMap<>();\nfor (CompilerInput input : inputs) {\n    for (String provide : input.getProvides()) {\n        if (providedModuleToInput.containsKey(provide)) {\n            // handle error: multiple provides for the same module\n            report error\n        }\n        providedModuleToInput.put(provide, input);\n    }\n}\n\nThen, for each input, for each require, find the provider input.\n\nThen, build the graph.\n\nOnce the graph is built, perform Kahn's algorithm.\n\nImplementing Kahn's algorithm:\n\n- Compute in-degree for each node.\n\n- Initialize a queue with nodes having in-degree zero.\n\n- While queue is not empty:\n\n    - Dequeue a node.\n\n    - Add to sorted list.\n\n    - For each neighbor, reduce in-degree by one. If in-degree becomes zero, enqueue.\n\n- If sorted list size is less than total nodes, there's a cycle.\n\nSo, in code:\n\n// Build the graph\nMap<CompilerInput, List<CompilerInput>> graph = new HashMap<>();\nMap<CompilerInput, Integer> inDegree = new HashMap<>();\n\nfor (CompilerInput input : inputs) {\n    graph.put(input, new ArrayList<>());\n    inDegree.put(input, 0);\n}\n\nfor (CompilerInput input : inputs) {\n    for (String require : input.getRequires()) {\n        CompilerInput provider = providedModuleToInput.get(require);\n        if (provider != null && provider != input) { // assuming input can't depend on itself\n            graph.get(provider).add(input);\n            inDegree.put(input, inDegree.get(input) + 1);\n        }\n    }\n}\n\n// Kahn's algorithm\nQueue<CompilerInput> queue = new LinkedList<>();\nList<CompilerInput> sortedInputs = new ArrayList<>();\n\nfor (CompilerInput input : inputs) {\n    if (inDegree.get(input) == 0) {\n        queue.add(input);\n    }\n}\n\nwhile (!queue.isEmpty()) {\n    CompilerInput current = queue.poll();\n    sortedInputs.add(current);\n\n    for (CompilerInput neighbor : graph.get(current)) {\n        inDegree.put(neighbor, inDegree.get(neighbor) - 1);\n        if (inDegree.get(neighbor) == 0) {\n            queue.add(neighbor);\n        }\n    }\n}\n\nif (sortedInputs.size() != inputs.size()) {\n    // circular dependency\n    throw new CircularDependencyException(\"Circular dependency detected\");\n}\n\ninputs = sortedInputs;\n\nWait, but this is a lot of code to add within the parseInputs function. So, perhaps the user expects me to replace the manageDependencies call with this logic.\n\nSo, in the parseInputs function, the code:\n\ninputs =\n    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n    .manageDependencies(options.dependencyOptions, inputs);\n\nwould be replaced with the above logic.\n\nBut I also need to handle exceptions, like CircularDependencyException and MissingProvideException, as in the original code.\n\nSo, wrapping this in a try-catch block.\n\nSo, putting it all together:\n\nWithin parseInputs(), after the for loop that adds provides, I'll have:\n\nif (options.dependencyOptions.needsManagement() &&\n    !options.skipAllPasses &&\n    options.closurePass) {\n\n    // Build providedModuleToInput map\n    Map<String, CompilerInput> providedModuleToInput = new HashMap<>();\n    for (CompilerInput input : inputs) {\n        for (String provide : input.getProvides()) {\n            if (providedModuleToInput.containsKey(provide)) {\n                report(JSError.make(MISSING_ENTRY_ERROR, \"Module '\" + provide + \"' is provided by multiple inputs.\"));\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            providedModuleToInput.put(provide, input);\n        }\n    }\n\n    // Build dependency graph\n    Map<CompilerInput, List<CompilerInput>> graph = new HashMap<>();\n    Map<CompilerInput, Integer> inDegree = new HashMap<>();\n\n    for (CompilerInput input : inputs) {\n        graph.put(input, new ArrayList<>());\n        inDegree.put(input, 0);\n    }\n\n    for (CompilerInput input : inputs) {\n        for (String require : input.getRequires()) {\n            CompilerInput provider = providedModuleToInput.get(require);\n            if (provider != null && !provider.equals(input)) {\n                graph.get(provider).add(input);\n                inDegree.put(input, inDegree.get(input) + 1);\n            }\n        }\n    }\n\n    // Kahn's algorithm\n    Queue<CompilerInput> queue = new LinkedList<>();\n    List<CompilerInput> sortedInputs = new ArrayList<>();\n\n    for (CompilerInput input : inputs) {\n        if (inDegree.get(input) == 0) {\n            queue.add(input);\n        }\n    }\n\n    while (!queue.isEmpty()) {\n        CompilerInput current = queue.poll();\n        sortedInputs.add(current);\n\n        for (CompilerInput neighbor : graph.get(current)) {\n            inDegree.put(neighbor, inDegree.get(neighbor) - 1);\n            if (inDegree.get(neighbor) == 0) {\n                queue.add(neighbor);\n            }\n        }\n    }\n\n    if (sortedInputs.size() != inputs.size()) {\n        throw new CircularDependencyException(\"Circular dependency detected\");\n    }\n\n    inputs = sortedInputs;\n    staleInputs = true;\n} catch (CircularDependencyException e) {\n    report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n    if (hasErrors()) {\n        return null;\n    }\n} catch (MissingProvideException e) {\n    report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n    if (hasErrors()) {\n        return null;\n    }\n}\n\nWait, but in the original code, the manageDependencies method is called, which may throw these exceptions. So, in the new code, I'm throwing CircularDependencyException, which is caught in the same way.\n\nBut I also need to handle cases where a required module is not provided by any input, which would be a MissingProvideException.\n\nSo, in the code above, when building the graph, if a required module is not found in providedModuleToInput, then provider is null. So, in that case, we should throw a MissingProvideException.\n\nSo, in the loop where we process requires:\n\nfor (String require : input.getRequires()) {\n    CompilerInput provider = providedModuleToInput.get(require);\n    if (provider == null) {\n        throw new MissingProvideException(\"Module '\" + require + \"' is required but not provided.\");\n    }\n    if (provider != input) {\n        graph.get(provider).add(input);\n        inDegree.put(input, inDegree.get(input) + 1);\n    }\n}\n\nWait, but this would throw an exception during the building of the graph, which is inside the try block. So, the catch block will handle it.\n\nSo, putting it all together, the code within the if block becomes:\n\ntry {\n    // Build providedModuleToInput map\n    Map<String, CompilerInput> providedModuleToInput = new HashMap<>();\n    for (CompilerInput input : inputs) {\n        for (String provide : input.getProvides()) {\n            if (providedModuleToInput.containsKey(provide)) {\n                report(JSError.make(MISSING_ENTRY_ERROR, \"Module '\" + provide + \"' is provided by multiple inputs.\"));\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            providedModuleToInput.put(provide, input);\n        }\n    }\n\n    // Check for missing provides\n    for (CompilerInput input : inputs) {\n        for (String require : input.getRequires()) {\n            if (!providedModuleToInput.containsKey(require)) {\n                throw new MissingProvideException(\"Module '\" + require + \"' is required but not provided.\");\n            }\n        }\n    }\n\n    // Build dependency graph\n    Map<CompilerInput, List<CompilerInput>> graph = new HashMap<>();\n    Map<CompilerInput, Integer> inDegree = new HashMap<>();\n\n    for (CompilerInput input : inputs) {\n        graph.put(input, new ArrayList<>());\n        inDegree.put(input, 0);\n    }\n\n    for (CompilerInput input : inputs) {\n        for (String require : input.getRequires()) {\n            CompilerInput provider = providedModuleToInput.get(require);\n            if (provider != input) {\n                graph.get(provider).add(input);\n                inDegree.put(input, inDegree.get(input) + 1);\n            }\n        }\n    }\n\n    // Kahn's algorithm\n    Queue<CompilerInput> queue = new LinkedList<>();\n    List<CompilerInput> sortedInputs = new ArrayList<>();\n\n    for (CompilerInput input : inputs) {\n        if (inDegree.get(input) == 0) {\n            queue.add(input);\n        }\n    }\n\n    while (!queue.isEmpty()) {\n        CompilerInput current = queue.poll();\n        sortedInputs.add(current);\n\n        for (CompilerInput neighbor : graph.get(current)) {\n            inDegree.put(neighbor, inDegree.get(neighbor) - 1);\n            if (inDegree.get(neighbor) == 0) {\n                queue.add(neighbor);\n            }\n        }\n    }\n\n    if (sortedInputs.size() != inputs.size()) {\n        throw new CircularDependencyException(\"Circular dependency detected\");\n    }\n\n    inputs = sortedInputs;\n    staleInputs = true;\n} catch (CircularDependencyException e) {\n    report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n    if (hasErrors()) {\n        return null;\n    }\n} catch (MissingProvideException e) {\n    report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n    if (hasErrors()) {\n        return null;\n    }\n}\n\nThis way, the dependencies are correctly sorted using topological sorting, which should fix the issue with goog.provide and goog.require ordering.\n\nI think this should address the root cause. Now, I'll need to write the fixed parseInputs function incorporating this change.\n</think>\n\n```java\nNode parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();",
      "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    // Check if inputs need to be rebuilt from modules.\n    boolean staleInputs = false;\n\n    // Check if the sources need to be re-ordered.\n    if (options.dependencyOptions.needsManagement() &&\n        !options.skipAllPasses &&\n        options.closurePass &&\n        options.compilationLevel != CompilationLevel.WHITESPACE_ONLY) {\n      for (CompilerInput input : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST during initial parse.\n      if (n == null) {\n        continue;\n      }\n\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          // If the input file is explicitly marked as an externs file, then\n          // assume the programmer made a mistake and throw it into\n          // the externs pile anyways.\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n\n          input.getModule().remove(input);\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
      "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer tracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n\n    // Check if inputs need to be rebuilt from modules.\n    boolean staleInputs = false;\n\n    // Check if the sources need to be re-ordered.\n    if (options.dependencyOptions.needsManagement() &&\n        !options.skipAllPasses &&\n        options.closurePass) {\n      // Create a dependency graph\n      DependencyGraph graph = new DependencyGraph();\n      \n      // Add nodes for each input\n      for (CompilerInput input : inputs) {\n        graph.addNode(input);\n        \n        // Forward-declare all the provided types\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n          graph.addProvide(input, provide);\n        }\n      }\n\n      // Build dependencies by finding requires and matching to provides\n      for (CompilerInput input : inputs) {\n        for (String require : input.getRequires()) {\n          CompilerInput provider = graph.findProvider(require);\n          if (provider != null) {\n            graph.addDependency(input, provider);\n          }\n        }\n      }\n\n      // Perform topological sort\n      try {\n        inputs = graph.topologicalSort();\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST during initial parse.\n      if (n == null) {\n        continue;\n      }\n\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          // If the input file is explicitly marked as an externs file, then\n          // assume the programmer made a mistake and throw it into\n          // the externs pile anyways.\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n\n          input.getModule().remove(input);\n\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    // Build the AST.\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n\n      jsRoot.addChildToBack(n);\n    }\n\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}\n\n// DependencyGraph class implementation\nclass DependencyGraph {\n  private final Map<CompilerInput, Set<CompilerInput>> dependencies =\n      new HashMap<>();\n  private final Map<String, CompilerInput> provides = new HashMap<>();\n  \n  void addNode(CompilerInput input) {\n    dependencies.putIfAbsent(input, new HashSet<>());\n  }\n  \n  void addProvide(CompilerInput input, String provide) {\n    provides.put(provide, input);\n  }\n  \n  void addDependency(CompilerInput input, CompilerInput dependency) {\n    dependencies.get(input).add(dependency);\n  }\n  \n  CompilerInput findProvider(String provide) {\n    return provides.get(provide);\n  }\n  \n  List<CompilerInput> topologicalSort() throws CircularDependencyException {\n    List<CompilerInput> sorted = new ArrayList<>();\n    Set<CompilerInput> visited = new HashSet<>();\n    Set<CompilerInput> visiting = new HashSet<>();\n    \n    for (CompilerInput node : dependencies.keySet()) {\n      if (!visited.contains(node)) {\n        visit(node, visiting, visited, sorted);\n      }\n    }\n    return sorted;\n  }\n  \n  private void visit(CompilerInput node, Set<CompilerInput> visiting,\n      Set<CompilerInput> visited, List<CompilerInput> sorted)\n      throws CircularDependencyException {\n    if (visiting.contains(node)) {\n      throw new CircularDependencyException(\"Circular dependency detected\");\n    }\n    if (!visited.contains(node)) {\n      visiting.add(node);\n      for (CompilerInput dep : dependencies.get(node)) {\n        visit(dep, visiting, visited, sorted);\n      }\n      visiting.remove(node);\n      visited.add(node);\n      sorted.add(node);\n    }\n  }\n}\n\n// Exception classes\nclass CircularDependencyException extends Exception {\n  public CircularDependencyException(String message) {\n    super(message);\n  }\n}\n\nclass MissingProvideException extends Exception {\n  public MissingProvideException(String message) {\n    super(message);\n  }\n}"
    ]
  }
}