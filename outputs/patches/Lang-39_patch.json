{
  "Lang-39": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function does not properly handle null values in the replacement list. When a null value is encountered, the function attempts to access its length, resulting in a NullPointerException.\nSuggestion: Add Null Check for Replacement List\nOne possible solution is to add a null check for the replacement list before attempting to access its elements. This can be done by adding a simple if statement to check if the replacement list is null or if any of its elements are null. If a null value is found, the function can either ignore it or throw a custom exception. The modified code would look like this:\n\n```java\nfor (int i = 0; i < searchLength; i++) {\n    if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n        searchList[i].length() == 0 || replacementList[i] == null) {\n        replacementList[i] = \"\"; // or throw a custom exception\n    }\n    // rest of the code\n}\n```\n// Buggy Function\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; // assume 3 matches\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function does not properly handle null values in the replacement list. When a null value is encountered, the function attempts to access its length, resulting in a NullPointerException.\nSuggestion: Use Optional Class to Handle Null Values\nAnother possible solution is to use the Optional class to handle null values in the replacement list. The Optional class provides a way to represent a value that may or may not be present. By using Optional, the function can avoid NullPointerExceptions and provide a more robust way of handling null values. The modified code would look like this:\n\n```java\nfor (int i = 0; i < searchLength; i++) {\n    Optional<String> replacement = Optional.ofNullable(replacementList[i]);\n    if (replacement.isPresent()) {\n        // rest of the code\n    } else {\n        replacementList[i] = \"\"; // or throw a custom exception\n    }\n}\n```\n// Buggy Function\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; // assume 3 matches\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function does not properly handle null values in the replacement list. When a null value is encountered, the function attempts to access its length, resulting in a NullPointerException.\nSuggestion: Modify the Function to Handle Null Replacements\nA third possible solution is to modify the function to handle null replacements explicitly. This can be done by adding a special case to handle null replacements, such as ignoring them or replacing them with an empty string. This approach requires modifying the function's logic to handle null replacements correctly. The modified code would look like this:\n\n```java\nfor (int i = 0; i < searchLength; i++) {\n    if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n        searchList[i].length() == 0 || replacementList[i] == null) {\n        continue; // ignore null replacements\n    }\n    // rest of the code\n}\n```\n// Buggy Function\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; // assume 3 matches\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    // Replace null elements in replacementList with empty strings\n    for (int i = 0; i < replacementList.length; i++) {\n        if (replacementList[i] == null) {\n            replacementList[i] = \"\";\n        }\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        int searchLen = searchList[i] == null ? 0 : searchList[i].length();\n        int replaceLen = replacementList[i].length();\n        int greater = replaceLen - searchLen;\n        if (greater > 0) {\n            increase += 3 * greater; // assume 3 matches\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
      "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    int increase = 0;\n\n    for (int i = 0; i < searchList.length; i++) {\n        String replacement = replacementList[i];\n        int replacementLen = replacement != null ? replacement.length() : 0;\n        String search = searchList[i];\n        int searchLen = search != null ? search.length() : 0;\n        int greater = replacementLen - searchLen;\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
      "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; // assume 3 matches\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}"
    ]
  }
}