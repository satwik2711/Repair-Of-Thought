{
  "Gson-13": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The bug is caused by the incorrect handling of negative zeros in the `peekNumber()` function. Specifically, when the input is '-0', the function incorrectly returns '0' instead of '-0'. This is because the function does not properly handle the case where the input is a negative zero.\nSuggestion: Handle Negative Zeros Explicitly\nIn this suggestion, we add an explicit check for negative zeros in the `peekNumber()` function. We can add a new variable `isNegativeZero` to track whether the input is a negative zero. If the input is a negative zero, we set `isNegativeZero` to true and return '-0' instead of '0'. This can be achieved by modifying the code as follows:\n\n```java\n// ...\n\n// We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n    || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n} else {\n    // Handle negative zeros explicitly\n    if (negative && value == 0) {\n        return \"-0\";\n    }\n    return PEEKED_NONE;\n}\n\n// ...\n```\n// Buggy Function\nprivate int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The bug is caused by the incorrect handling of negative zeros in the `peekNumber()` function. Specifically, when the input is '-0', the function incorrectly returns '0' instead of '-0'. This is because the function does not properly handle the case where the input is a negative zero.\nSuggestion: Modify the Value Calculation\nIn this suggestion, we modify the line `value = -(c - '0');` to correctly handle negative zeros. We can change this line to `value = (negative ? -(c - '0') : (c - '0'));` to ensure that negative zeros are handled correctly. This can be achieved by modifying the code as follows:\n\n```java\n// ...\n\n// We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n    || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n} else {\n    // Modify the value calculation to correctly handle negative zeros\n    value = (negative ? -(c - '0') : (c - '0'));\n    return PEEKED_NONE;\n}\n\n// ...\n```\n// Buggy Function\nprivate int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The bug is caused by the incorrect handling of negative zeros in the `peekNumber()` function. Specifically, when the input is '-0', the function incorrectly returns '0' instead of '-0'. This is because the function does not properly handle the case where the input is a negative zero.\nSuggestion: Use a Different Approach\nIn this suggestion, we use a different approach to handle negative numbers. Instead of using the `value` variable to store the number, we can use a string to build the number. This approach would allow us to correctly handle negative zeros. This can be achieved by modifying the code as follows:\n\n```java\n// ...\n\n// We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nString number = \"\";\nif (negative) {\n    number += \"-\";\n}\nnumber += value;\nif (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = Long.parseLong(number);\n    pos += i;\n    return peeked = PEEKED_LONG;\n} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n    || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n} else {\n    return PEEKED_NONE;\n}\n\n// ...\n```\n// Buggy Function\nprivate int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n\n        char c = buffer[p + i];\n        switch (c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && !(negative && value == 0)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n            || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}",
      "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n\n        char c = buffer[p + i];\n        switch (c) {\n        case '-':\n            if (last == NUMBER_CHAR_NONE) {\n                negative = true;\n                last = NUMBER_CHAR_SIGN;\n                continue;\n            } else if (last == NUMBER_CHAR_EXP_E) {\n                last = NUMBER_CHAR_EXP_SIGN;\n                continue;\n            }\n            return PEEKED_NONE;\n\n        case '+':\n            if (last == NUMBER_CHAR_EXP_E) {\n                last = NUMBER_CHAR_EXP_SIGN;\n                continue;\n            }\n            return PEEKED_NONE;\n\n        case 'e':\n        case 'E':\n            if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                last = NUMBER_CHAR_EXP_E;\n                continue;\n            }\n            return PEEKED_NONE;\n\n        case '.':\n            if (last == NUMBER_CHAR_DIGIT) {\n                last = NUMBER_CHAR_DECIMAL;\n                continue;\n            }\n            return PEEKED_NONE;\n\n        default:\n            if (c < '0' || c > '9') {\n                if (!isLiteral(c)) {\n                    break charactersOfNumber;\n                }\n                return PEEKED_NONE;\n            }\n            if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                value = -(c - '0');\n                last = NUMBER_CHAR_DIGIT;\n            } else if (last == NUMBER_CHAR_DIGIT) {\n                if (value == 0) {\n                    return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n                }\n                long newValue = value * 10 - (c - '0');\n                fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                        || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                value = newValue;\n            } else if (last == NUMBER_CHAR_DECIMAL) {\n                last = NUMBER_CHAR_FRACTION_DIGIT;\n            } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                last = NUMBER_CHAR_EXP_DIGIT;\n            }\n        }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong) {\n        if (value == 0 && negative) {\n            // Treat -0 as PEEKED_NUMBER to preserve the sign\n            peekedNumberLength = i;\n            return peeked = PEEKED_NUMBER;\n        } else if (value != Long.MIN_VALUE || negative) {\n            peekedLong = negative ? value : -value;\n            pos += i;\n            return peeked = PEEKED_LONG;\n        }\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n            || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}",
      "private int peekNumber() throws IOException {\n  // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n\n  long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n\n  int i = 0;\n\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    if (value == 0 && negative) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    }\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}"
    ]
  }
}