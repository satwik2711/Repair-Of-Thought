{
  "Gson-5": {
    "prompt": [
      "// Provide a fix for the buggy function.\nRoot cause: The root cause of the issue is that the function is not correctly handling the timezone offset when it is not in the format '+hh:mm' or '-hh:mm'. The function is expecting a colon (:) after the hour in the timezone offset, but in the date string '1970-01-01T01:00:00+01', there is no colon. This is causing the function to throw an exception when trying to parse the timezone offset.\nSuggestion: Modify Timezone Offset Parsing\nThe function should be modified to correctly parse the timezone offset when it is not in the format '+hh:mm' or '-hh:mm'. This can be done by checking if the character after the hour in the timezone offset is a digit, and if so, parsing the offset as '+hh' or '-hh'. The modified code should look like this:\n```java\n// extract timezone\nif (date.length() <= offset) {\n    throw new IllegalArgumentException(\"No time zone indicator\");\n}\n\nTimeZone timezone = null;\nchar timezoneIndicator = date.charAt(offset);\n\nif (timezoneIndicator == 'Z') {\n    timezone = TIMEZONE_UTC;\n    offset += 1;\n} else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n    String timezoneOffset = date.substring(offset);\n\n    // Check if the offset is in the format '+hh' or '-hh'\n    if (timezoneOffset.length() == 3) {\n        String hours = timezoneOffset.substring(1);\n        timezone = TimeZone.getTimeZone(\"GMT\" + timezoneIndicator + hours + \"00\");\n    } else {\n        // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n        if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n            timezone = TIMEZONE_UTC;\n        } else {\n            // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n            //    not sure why, but that's the way it looks. Further, Javadocs for\n            //    `java.util.TimeZone` specifically instruct use of GMT as base for\n            //    custom timezones... odd.\n            String timezoneId = \"GMT\" + timezoneOffset;\n\n            timezone = TimeZone.getTimeZone(timezoneId);\n\n            String act = timezone.getID();\n            if (!act.equals(timezoneId)) {\n                /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                 *    one without. If so, don't sweat.\n                 *   Yes, very inefficient. Hopefully not hit often.\n                 *   If it becomes a perf problem, add 'loose' comparison instead.\n                 */\n                String cleaned = act.replace(\":\", \"\");\n                if (!cleaned.equals(timezoneId)) {\n                    throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \"\n                            + timezone.getID());\n                }\n            }\n        }\n    }\n    offset += timezoneOffset.length();\n} else {\n    throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n}\n```\n// Buggy Function\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch (parseEndOffset - offset) { // number of digits parsed\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        default:\n                            milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                  String timezoneId = \"UTC\" + timezoneOffset;\n\n                timezone = TimeZone.getTimeZone(timezoneId);\n\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don't sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add 'loose' comparison instead.\n                     */\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                +timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\"+fail.getClass().getName()+\")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}\n// Fixed Function",
      "// Provide a fix for the buggy function.\nRoot cause: The root cause of the issue is that the function is not correctly handling the timezone offset when it is not in the format '+hh:mm' or '-hh:mm'. The function is expecting a colon (:) after the hour in the timezone offset, but in the date string '1970-01-01T01:00:00+01', there is no colon. This is causing the function to throw an exception when trying to parse the timezone offset.\nSuggestion: Add Error Handling for Invalid Timezone Offsets\nThe function should be modified to handle invalid timezone offsets, such as those that are not in the expected format. This can be done by adding error handling code to check if the timezone offset is valid, and if not, throwing an exception. The modified code should look like this:\n```java\n// extract timezone\nif (date.length() <= offset) {\n    throw new IllegalArgumentException(\"No time zone indicator\");\n}\n\nTimeZone timezone = null;\nchar timezoneIndicator = date.charAt(offset);\n\nif (timezoneIndicator == 'Z') {\n    timezone = TIMEZONE_UTC;\n    offset += 1;\n} else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n    String timezoneOffset = date.substring(offset);\n\n    // Check if the offset is valid\n    if (!isValidTimezoneOffset(timezoneOffset)) {\n        throw new IndexOutOfBoundsException(\"Invalid time zone offset: \" + timezoneOffset);\n    }\n\n    // ... rest of the code ...\n}\n\n// ...\n\nprivate boolean isValidTimezoneOffset(String offset) {\n    if (offset.length() < 3 || offset.length() > 6) {\n        return false;\n    }\n    char firstChar = offset.charAt(0);\n    if (firstChar != '+' && firstChar != '-') {\n        return false;\n    }\n    for (int i = 1; i < offset.length(); i++) {\n        char c = offset.charAt(i);\n        if (!Character.isDigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n// Buggy Function\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch (parseEndOffset - offset) { // number of digits parsed\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        default:\n                            milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                  String timezoneId = \"UTC\" + timezoneOffset;\n\n                timezone = TimeZone.getTimeZone(timezoneId);\n\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don't sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add 'loose' comparison instead.\n                     */\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                +timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\"+fail.getClass().getName()+\")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}\n// Fixed Function",
      "// Provide a fix for the buggy function.\nRoot cause: The root cause of the issue is that the function is not correctly handling the timezone offset when it is not in the format '+hh:mm' or '-hh:mm'. The function is expecting a colon (:) after the hour in the timezone offset, but in the date string '1970-01-01T01:00:00+01', there is no colon. This is causing the function to throw an exception when trying to parse the timezone offset.\nSuggestion: Improve Code Comments and Documentation\nThe function should be modified to include improved code comments and documentation, to make it easier for other developers to understand how the function works and how to use it correctly. This can be done by adding comments to explain the purpose of each section of code, and by adding documentation to the function to describe its parameters, return value, and any exceptions it may throw. The modified code should look like this:\n```java\n/**\n * Parse a date from an ISO-8601 formatted string.\n * \n * @param date the ISO-8601 formatted string to parse\n * @param pos the position to start parsing from\n * @return the parsed date\n * @throws ParseException if the date is not in the correct format\n */\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    // ... rest of the code ...\n}\n```\n// Buggy Function\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch (parseEndOffset - offset) { // number of digits parsed\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        default:\n                            milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                  String timezoneId = \"UTC\" + timezoneOffset;\n\n                timezone = TimeZone.getTimeZone(timezoneId);\n\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don't sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add 'loose' comparison instead.\n                     */\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                +timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\"+fail.getClass().getName()+\")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}\n// Fixed Function"
    ],
    "patches": [
      "```java\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset",
      "```java\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset",
      "```java\n/**\n * Parse a date from an ISO-8601 formatted string.\n * \n * @param date the ISO-8601 formatted string to parse\n * @param pos the position to start parsing from\n * @return the parsed date\n * @throws ParseException if the date is not in the correct format\n */\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // Extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // Extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // Extract day\n        int day = parseInt(date, offset, offset += 2);\n        // Default time values\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // Always use 0 otherwise returned date will include millis of current time\n\n        // If the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n            // Extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // Second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // Truncate up to 3 leap seconds\n                    // Milliseconds can be optional in the format\n                    if ("
    ]
  }
}