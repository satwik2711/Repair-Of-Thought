{
  "Lang-18": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is in the `parsePattern()` function, specifically in the handling of the `G` pattern character, which represents the era designator. The function is not correctly handling the case where the `G` pattern character is repeated multiple times.\nSuggestion: Modify the parsePattern() function to handle repeated G pattern characters\nWe can modify the `parsePattern()` function to correctly handle the case where the `G` pattern character is repeated multiple times. We can add a loop to the `switch` statement to handle repeated `G` pattern characters. Here is an example of the modified code:\n```java\ncase 'G': // era designator (text)\n    int count = 0;\n    while (i + count < length && mPattern.charAt(i + count) == 'G') {\n        count++;\n    }\n    rule = new TextField(Calendar.ERA, ERAs);\n    for (int j = 0; j < count; j++) {\n        rules.add(rule);\n    }\n    i += count - 1;\n    break;\n```\nThis code adds a loop to the `switch` statement to handle repeated `G` pattern characters. It counts the number of repeated `G` pattern characters and adds the corresponding number of `TextField` rules to the list of rules.\n// Buggy Function\nprotected List<Rule> parsePattern() {\n    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n    List<Rule> rules = new ArrayList<Rule>();\n\n    String[] ERAs = symbols.getEras();\n    String[] months = symbols.getMonths();\n    String[] shortMonths = symbols.getShortMonths();\n    String[] weekdays = symbols.getWeekdays();\n    String[] shortWeekdays = symbols.getShortWeekdays();\n    String[] AmPmStrings = symbols.getAmPmStrings();\n\n    int length = mPattern.length();\n    int[] indexRef = new int[1];\n\n    for (int i = 0; i < length; i++) {\n        indexRef[0] = i;\n        String token = parseToken(mPattern, indexRef);\n        i = indexRef[0];\n\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n\n        Rule rule;\n        char c = token.charAt(0);\n\n        switch (c) {\n        case 'G': // era designator (text)\n            rule = new TextField(Calendar.ERA, ERAs);\n            break;\n        case 'y': // year (number)\n            if (tokenLen >= 4) {\n                rule = selectNumberRule(Calendar.YEAR, tokenLen);\n            } else {\n                rule = TwoDigitYearField.INSTANCE;\n            }\n            break;\n        case 'M': // month in year (text and number)\n            if (tokenLen >= 4) {\n                rule = new TextField(Calendar.MONTH, months);\n            } else if (tokenLen == 3) {\n                rule = new TextField(Calendar.MONTH, shortMonths);\n            } else if (tokenLen == 2) {\n                rule = TwoDigitMonthField.INSTANCE;\n            } else {\n                rule = UnpaddedMonthField.INSTANCE;\n            }\n            break;\n        case 'd': // day in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n            break;\n        case 'h': // hour in am/pm (number, 1..12)\n            rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n            break;\n        case 'H': // hour in day (number, 0..23)\n            rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n            break;\n        case 'm': // minute in hour (number)\n            rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n            break;\n        case 's': // second in minute (number)\n            rule = selectNumberRule(Calendar.SECOND, tokenLen);\n            break;\n        case 'S': // millisecond (number)\n            rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n            break;\n        case 'E': // day in week (text)\n            rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n            break;\n        case 'D': // day in year (number)\n            rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n            break;\n        case 'F': // day of week in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n            break;\n        case 'w': // week in year (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n            break;\n        case 'W': // week in month (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n            break;\n        case 'a': // am/pm marker (text)\n            rule = new TextField(Calendar.AM_PM, AmPmStrings);\n            break;\n        case 'k': // hour in day (1..24)\n            rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n            break;\n        case 'K': // hour in am/pm (0..11)\n            rule = selectNumberRule(Calendar.HOUR, tokenLen);\n            break;\n        case 'z': // time zone (text)\n            if (tokenLen >= 4) {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n            } else {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n            }\n            break;\n        case 'Z': // time zone (value)\n            if (tokenLen == 1) {\n                rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n            } else {\n                rule = TimeZoneNumberRule.INSTANCE_COLON;\n            }\n            break;\n        case '\\'': // literal text\n            String sub = token.substring(1);\n            if (sub.length() == 1) {\n                rule = new CharacterLiteral(sub.charAt(0));\n            } else {\n                rule = new StringLiteral(sub);\n            }\n            break;\n        default:\n            throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n\n        rules.add(rule);\n    }\n\n    return rules;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is in the `parsePattern()` function, specifically in the handling of the `G` pattern character, which represents the era designator. The function is not correctly handling the case where the `G` pattern character is repeated multiple times.\nSuggestion: Add a new rule for repeated G pattern characters\nWe can add a new rule to the `parsePattern()` function to handle repeated `G` pattern characters. We can create a new `RepeatedTextField` rule that takes the era designator and the number of repetitions as parameters. Here is an example of the new rule:\n```java\npublic class RepeatedTextField extends Rule {\n    private String[] eraDesignators;\n    private int repetitions;\n\n    public RepeatedTextField(String[] eraDesignators, int repetitions) {\n        this.eraDesignators = eraDesignators;\n        this.repetitions = repetitions;\n    }\n\n    public void format(Appendable buffer, Calendar calendar) {\n        for (int i = 0; i < repetitions; i++) {\n            buffer.append(eraDesignators[calendar.get(Calendar.ERA)]);\n        }\n    }\n}\n```\nWe can then modify the `parsePattern()` function to use the new `RepeatedTextField` rule when it encounters repeated `G` pattern characters. Here is an example of the modified code:\n```java\ncase 'G': // era designator (text)\n    int count = 0;\n    while (i + count < length && mPattern.charAt(i + count) == 'G') {\n        count++;\n    }\n    rule = new RepeatedTextField(ERAs, count);\n    rules.add(rule);\n    i += count - 1;\n    break;\n```\nThis code adds a new `RepeatedTextField` rule to handle repeated `G` pattern characters. It creates a new instance of the rule with the era designator and the number of repetitions, and adds it to the list of rules.\n// Buggy Function\nprotected List<Rule> parsePattern() {\n    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n    List<Rule> rules = new ArrayList<Rule>();\n\n    String[] ERAs = symbols.getEras();\n    String[] months = symbols.getMonths();\n    String[] shortMonths = symbols.getShortMonths();\n    String[] weekdays = symbols.getWeekdays();\n    String[] shortWeekdays = symbols.getShortWeekdays();\n    String[] AmPmStrings = symbols.getAmPmStrings();\n\n    int length = mPattern.length();\n    int[] indexRef = new int[1];\n\n    for (int i = 0; i < length; i++) {\n        indexRef[0] = i;\n        String token = parseToken(mPattern, indexRef);\n        i = indexRef[0];\n\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n\n        Rule rule;\n        char c = token.charAt(0);\n\n        switch (c) {\n        case 'G': // era designator (text)\n            rule = new TextField(Calendar.ERA, ERAs);\n            break;\n        case 'y': // year (number)\n            if (tokenLen >= 4) {\n                rule = selectNumberRule(Calendar.YEAR, tokenLen);\n            } else {\n                rule = TwoDigitYearField.INSTANCE;\n            }\n            break;\n        case 'M': // month in year (text and number)\n            if (tokenLen >= 4) {\n                rule = new TextField(Calendar.MONTH, months);\n            } else if (tokenLen == 3) {\n                rule = new TextField(Calendar.MONTH, shortMonths);\n            } else if (tokenLen == 2) {\n                rule = TwoDigitMonthField.INSTANCE;\n            } else {\n                rule = UnpaddedMonthField.INSTANCE;\n            }\n            break;\n        case 'd': // day in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n            break;\n        case 'h': // hour in am/pm (number, 1..12)\n            rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n            break;\n        case 'H': // hour in day (number, 0..23)\n            rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n            break;\n        case 'm': // minute in hour (number)\n            rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n            break;\n        case 's': // second in minute (number)\n            rule = selectNumberRule(Calendar.SECOND, tokenLen);\n            break;\n        case 'S': // millisecond (number)\n            rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n            break;\n        case 'E': // day in week (text)\n            rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n            break;\n        case 'D': // day in year (number)\n            rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n            break;\n        case 'F': // day of week in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n            break;\n        case 'w': // week in year (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n            break;\n        case 'W': // week in month (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n            break;\n        case 'a': // am/pm marker (text)\n            rule = new TextField(Calendar.AM_PM, AmPmStrings);\n            break;\n        case 'k': // hour in day (1..24)\n            rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n            break;\n        case 'K': // hour in am/pm (0..11)\n            rule = selectNumberRule(Calendar.HOUR, tokenLen);\n            break;\n        case 'z': // time zone (text)\n            if (tokenLen >= 4) {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n            } else {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n            }\n            break;\n        case 'Z': // time zone (value)\n            if (tokenLen == 1) {\n                rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n            } else {\n                rule = TimeZoneNumberRule.INSTANCE_COLON;\n            }\n            break;\n        case '\\'': // literal text\n            String sub = token.substring(1);\n            if (sub.length() == 1) {\n                rule = new CharacterLiteral(sub.charAt(0));\n            } else {\n                rule = new StringLiteral(sub);\n            }\n            break;\n        default:\n            throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n\n        rules.add(rule);\n    }\n\n    return rules;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is in the `parsePattern()` function, specifically in the handling of the `G` pattern character, which represents the era designator. The function is not correctly handling the case where the `G` pattern character is repeated multiple times.\nSuggestion: Use a StringBuilder to build the era designator string\nWe can use a `StringBuilder` to build the era designator string when the `G` pattern character is repeated multiple times. Here is an example of the modified code:\n```java\ncase 'G': // era designator (text)\n    int count = 0;\n    while (i + count < length && mPattern.charAt(i + count) == 'G') {\n        count++;\n    }\n    StringBuilder eraDesignator = new StringBuilder();\n    for (int j = 0; j < count; j++) {\n        eraDesignator.append(ERAs[calendar.get(Calendar.ERA)]);\n    }\n    rule = new TextField(Calendar.ERA, eraDesignator.toString());\n    rules.add(rule);\n    i += count - 1;\n    break;\n```\nThis code uses a `StringBuilder` to build the era designator string when the `G` pattern character is repeated multiple times. It creates a new `TextField` rule with the built era designator string and adds it to the list of rules.\n// Buggy Function\nprotected List<Rule> parsePattern() {\n    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n    List<Rule> rules = new ArrayList<Rule>();\n\n    String[] ERAs = symbols.getEras();\n    String[] months = symbols.getMonths();\n    String[] shortMonths = symbols.getShortMonths();\n    String[] weekdays = symbols.getWeekdays();\n    String[] shortWeekdays = symbols.getShortWeekdays();\n    String[] AmPmStrings = symbols.getAmPmStrings();\n\n    int length = mPattern.length();\n    int[] indexRef = new int[1];\n\n    for (int i = 0; i < length; i++) {\n        indexRef[0] = i;\n        String token = parseToken(mPattern, indexRef);\n        i = indexRef[0];\n\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n\n        Rule rule;\n        char c = token.charAt(0);\n\n        switch (c) {\n        case 'G': // era designator (text)\n            rule = new TextField(Calendar.ERA, ERAs);\n            break;\n        case 'y': // year (number)\n            if (tokenLen >= 4) {\n                rule = selectNumberRule(Calendar.YEAR, tokenLen);\n            } else {\n                rule = TwoDigitYearField.INSTANCE;\n            }\n            break;\n        case 'M': // month in year (text and number)\n            if (tokenLen >= 4) {\n                rule = new TextField(Calendar.MONTH, months);\n            } else if (tokenLen == 3) {\n                rule = new TextField(Calendar.MONTH, shortMonths);\n            } else if (tokenLen == 2) {\n                rule = TwoDigitMonthField.INSTANCE;\n            } else {\n                rule = UnpaddedMonthField.INSTANCE;\n            }\n            break;\n        case 'd': // day in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n            break;\n        case 'h': // hour in am/pm (number, 1..12)\n            rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n            break;\n        case 'H': // hour in day (number, 0..23)\n            rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n            break;\n        case 'm': // minute in hour (number)\n            rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n            break;\n        case 's': // second in minute (number)\n            rule = selectNumberRule(Calendar.SECOND, tokenLen);\n            break;\n        case 'S': // millisecond (number)\n            rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n            break;\n        case 'E': // day in week (text)\n            rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n            break;\n        case 'D': // day in year (number)\n            rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n            break;\n        case 'F': // day of week in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n            break;\n        case 'w': // week in year (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n            break;\n        case 'W': // week in month (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n            break;\n        case 'a': // am/pm marker (text)\n            rule = new TextField(Calendar.AM_PM, AmPmStrings);\n            break;\n        case 'k': // hour in day (1..24)\n            rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n            break;\n        case 'K': // hour in am/pm (0..11)\n            rule = selectNumberRule(Calendar.HOUR, tokenLen);\n            break;\n        case 'z': // time zone (text)\n            if (tokenLen >= 4) {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n            } else {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n            }\n            break;\n        case 'Z': // time zone (value)\n            if (tokenLen == 1) {\n                rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n            } else {\n                rule = TimeZoneNumberRule.INSTANCE_COLON;\n            }\n            break;\n        case '\\'': // literal text\n            String sub = token.substring(1);\n            if (sub.length() == 1) {\n                rule = new CharacterLiteral(sub.charAt(0));\n            } else {\n                rule = new StringLiteral(sub);\n            }\n            break;\n        default:\n            throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n\n        rules.add(rule);\n    }\n\n    return rules;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "protected List<Rule> parsePattern() {\n    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n    List<Rule> rules = new ArrayList<Rule>();\n\n    String[] ERAs = symbols.getEras();\n    String[] months = symbols.getMonths();\n    String[] shortMonths = symbols.getShortMonths();\n    String[] weekdays = symbols.getWeekdays();\n    String[] shortWeekdays = symbols.getShortWeekdays();\n    String[] AmPmStrings = symbols.getAmPmStrings();\n\n    int length = mPattern.length();\n    int[] indexRef = new int[1];\n\n    for (int i = 0; i < length; i++) {\n        indexRef[0] = i;\n        String token = parseToken(mPattern, indexRef);\n        i = indexRef[0];\n\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n\n        Rule rule;\n        char c = token.charAt(0);\n\n        switch (c) {\n        case 'G': // era designator (text)\n            int count = 0;\n            while (i + count < length && mPattern.charAt(i + count) == 'G') {\n                count++;\n            }\n            for (int j = 0; j < count; j++) {\n                rule = new TextField(Calendar.ERA, ERAs);\n                rules.add(rule);\n            }\n            i += count - 1;\n            break;\n        case 'y': // year (number)\n            if (tokenLen >= 4) {\n                rule = selectNumberRule(Calendar.YEAR, tokenLen);\n            } else {\n                rule = TwoDigitYearField.INSTANCE;\n            }\n            break;\n        case 'M': // month in year (text and number)\n            if (tokenLen >= 4) {\n                rule = new TextField(Calendar.MONTH, months);\n            } else if (tokenLen == 3) {\n                rule = new TextField(Calendar.MONTH, shortMonths);\n            } else if (tokenLen == 2) {\n                rule = TwoDigitMonthField.INSTANCE;\n            } else {\n                rule = UnpaddedMonthField.INSTANCE;\n            }\n            break;\n        case 'd': // day in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n            break;\n        case 'h': // hour in am/pm (number, 1..12)\n            rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n            break;\n        case 'H': // hour in day (number, 0..23)\n            rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n            break;\n        case 'm': // minute in hour (number)\n            rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n            break;\n        case 's': // second in minute (number)\n            rule = selectNumberRule(Calendar.SECOND, tokenLen);\n            break;\n        case 'S': // millisecond (number)\n            rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n            break;\n        case 'E': // day in week (text)\n            rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n            break;\n        case 'D': // day in year (number)\n            rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n            break;\n        case 'F': // day of week in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n            break;\n        case 'w': // week in year (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n            break;\n        case 'W': // week in month (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n            break;\n        case 'a': // am/pm marker (text)\n            rule = new TextField(Calendar.AM_PM, AmPmStrings);\n            break;\n        case 'k': // hour in day (1..24)\n            rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n            break;\n        case 'K': // hour in am/pm (0..11)\n            rule = selectNumberRule(Calendar.HOUR, tokenLen);\n            break;\n        case 'z': // time zone (text)\n            if (tokenLen >= 4) {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n            } else {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n            }\n            break;\n        case 'Z': // time zone (value)\n            if (tokenLen == 1) {\n                rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n            } else {\n                rule = TimeZoneNumberRule.INSTANCE_COLON;\n            }\n            break;\n        case '\\'': // literal text\n            String sub = token.substring(1);\n            if (sub.length() == 1) {\n                rule = new CharacterLiteral(sub.charAt(0));\n            } else {\n                rule = new StringLiteral(sub);\n            }\n            break;\n        default:\n            throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n\n        rules.add(rule);\n    }\n\n    return rules;\n}",
      "protected List<Rule> parsePattern() {\n    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n    List<Rule> rules = new ArrayList<Rule>();\n\n    String[] ERAs = symbols.getEras();\n    String[] months = symbols.getMonths();\n    String[] shortMonths = symbols.getShortMonths();\n    String[] weekdays = symbols.getWeekdays();\n    String[] shortWeekdays = symbols.getShortWeekdays();\n    String[] AmPmStrings = symbols.getAmPmStrings();\n\n    int length = mPattern.length();\n    int[] indexRef = new int[1];\n\n    for (int i = 0; i < length; i++) {\n        indexRef[0] = i;\n        String token = parseToken(mPattern, indexRef);\n        i = indexRef[0];\n\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n\n        Rule rule;\n        char c = token.charAt(0);\n\n        switch (c) {\n        case 'G': // era designator (text)\n            int count = 0;\n            while (i + count < length && mPattern.charAt(i + count) == 'G') {\n                count++;\n            }\n            rule = new RepeatedTextField(ERAs, count);\n            rules.add(rule);\n            i += count - 1;\n            break;\n        case 'y': // year (number)\n            if (tokenLen >= 4) {\n                rule = selectNumberRule(Calendar.YEAR, tokenLen);\n            } else {\n                rule = TwoDigitYearField.INSTANCE;\n            }\n            break;\n        case 'M': // month in year (text and number)\n            if (tokenLen >= 4) {\n                rule = new TextField(Calendar.MONTH, months);\n            } else if (tokenLen == 3) {\n                rule = new TextField(Calendar.MONTH, shortMonths);\n            } else if (tokenLen == 2) {\n                rule = TwoDigitMonthField.INSTANCE;\n            } else {\n                rule = UnpaddedMonthField.INSTANCE;\n            }\n            break;\n        case 'd': // day in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n            break;\n        case 'h': // hour in am/pm (number, 1..12)\n            rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n            break;\n        case 'H': // hour in day (number, 0..23)\n            rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n            break;\n        case 'm': // minute in hour (number)\n            rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n            break;\n        case 's': // second in minute (number)\n            rule = selectNumberRule(Calendar.SECOND, tokenLen);\n            break;\n        case 'S': // millisecond (number)\n            rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n            break;\n        case 'E': // day in week (text)\n            rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n            break;\n        case 'D': // day in year (number)\n            rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n            break;\n        case 'F': // day of week in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n            break;\n        case 'w': // week in year (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n            break;\n        case 'W': // week in month (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n            break;\n        case 'a': // am/pm marker (text)\n            rule = new TextField(Calendar.AM_PM, AmPmStrings);\n            break;\n        case 'k': // hour in day (1..24)\n            rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n            break;\n        case 'K': // hour in am/pm (0..11)\n            rule = selectNumberRule(Calendar.HOUR, tokenLen);\n            break;\n        case 'z': // time zone (text)\n            if (tokenLen >= 4) {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n            } else {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n            }\n            break;\n        case 'Z': // time zone (value)\n            if (tokenLen == 1) {\n                rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n            } else {\n                rule = TimeZoneNumberRule.INSTANCE_COLON;\n            }\n            break;\n        case '\\'': // literal text\n            String sub = token.substring(1);\n            if (sub.length() == 1) {\n                rule = new CharacterLiteral(sub.charAt(0));\n            } else {\n                rule = new StringLiteral(sub);\n            }\n            break;\n        default:\n            throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n\n        if (rule != null) {\n            rules.add(rule);\n        }\n    }\n\n    return rules;\n}\n\nprivate static class RepeatedTextField extends Rule {\n    private String[] eraDesignators;\n    private int repetitions;\n\n    public RepeatedTextField(String[] eraDesignators, int repetitions) {\n        this.eraDesignators = eraDesignators;\n        this.repetitions = repetitions;\n    }\n\n    public void format(Appendable buffer, Calendar calendar) {\n        for (int i = 0; i < repetitions; i++) {\n            buffer.append(eraDesignators[calendar.get(Calendar.ERA)]);\n        }\n    }\n}",
      "protected List<Rule> parsePattern() {\n    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n    List<Rule> rules = new ArrayList<Rule>();\n\n    String[] ERAs = symbols.getEras();\n    String[] months = symbols.getMonths();\n    String[] shortMonths = symbols.getShortMonths();\n    String[] weekdays = symbols.getWeekdays();\n    String[] shortWeekdays = symbols.getShortWeekdays();\n    String[] AmPmStrings = symbols.getAmPmStrings();\n\n    int length = mPattern.length();\n    int[] indexRef = new int[1];\n\n    for (int i = 0; i < length; i++) {\n        indexRef[0] = i;\n        String token = parseToken(mPattern, indexRef);\n        i = indexRef[0];\n\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n\n        Rule rule;\n        char c = token.charAt(0);\n\n        switch (c) {\n        case 'G': // era designator (text)\n            int count = 0;\n            while (i + count < length && mPattern.charAt(i + count) == 'G') {\n                count++;\n            }\n            StringBuilder eraDesignator = new StringBuilder();\n            for (int j = 0; j < count; j++) {\n                eraDesignator.append(ERAs[calendar.get(Calendar.ERA)]);\n            }\n            rule = new TextField(Calendar.ERA, eraDesignator.toString());\n            i += count - 1;\n            break;\n        case 'y': // year (number)\n            if (tokenLen >= 4) {\n                rule = selectNumberRule(Calendar.YEAR, tokenLen);\n            } else {\n                rule = TwoDigitYearField.INSTANCE;\n            }\n            break;\n        case 'M': // month in year (text and number)\n            if (tokenLen >= 4) {\n                rule = new TextField(Calendar.MONTH, months);\n            } else if (tokenLen == 3) {\n                rule = new TextField(Calendar.MONTH, shortMonths);\n            } else if (tokenLen == 2) {\n                rule = TwoDigitMonthField.INSTANCE;\n            } else {\n                rule = UnpaddedMonthField.INSTANCE;\n            }\n            break;\n        case 'd': // day in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n            break;\n        case 'h': // hour in am/pm (number, 1..12)\n            rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n            break;\n        case 'H': // hour in day (number, 0..23)\n            rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n            break;\n        case 'm': // minute in hour (number)\n            rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n            break;\n        case 's': // second in minute (number)\n            rule = selectNumberRule(Calendar.SECOND, tokenLen);\n            break;\n        case 'S': // millisecond (number)\n            rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n            break;\n        case 'E': // day in week (text)\n            rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n            break;\n        case 'D': // day in year (number)\n            rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n            break;\n        case 'F': // day of week in month (number)\n            rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n            break;\n        case 'w': // week in year (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n            break;\n        case 'W': // week in month (number)\n            rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n            break;\n        case 'a': // am/pm marker (text)\n            rule = new TextField(Calendar.AM_PM, AmPmStrings);\n            break;\n        case 'k': // hour in day (1..24)\n            rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n            break;\n        case 'K': // hour in am/pm (0..11)\n            rule = selectNumberRule(Calendar.HOUR, tokenLen);\n            break;\n        case 'z': // time zone (text)\n            if (tokenLen >= 4) {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n            } else {\n                rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n            }\n            break;\n        case 'Z': // time zone (value)\n            if (tokenLen == 1) {\n                rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n            } else {\n                rule = TimeZoneNumberRule.INSTANCE_COLON;\n            }\n            break;\n        case '\\'': // literal text\n            String sub = token.substring(1);\n            if (sub.length() == 1) {\n                rule = new CharacterLiteral(sub.charAt(0));\n            } else {\n                rule = new StringLiteral(sub);\n            }\n            break;\n        default:\n            throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n\n        rules.add(rule);\n    }\n\n    return rules;\n}"
    ]
  }
}