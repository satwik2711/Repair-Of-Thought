{
  "JacksonCore-23": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The `createInstance` method does not perform any checks on the subclass before creating a new instance of `DefaultPrettyPrinter`. This allows an invalid subclass to be used, leading to unexpected behavior.\nSuggestion: Add a Simple Subclass Check\nAdd a simple check to ensure that the subclass is an instance of `DefaultPrettyPrinter` before creating a new instance. This can be done using the `instanceof` operator. However, this approach may not be sufficient as it does not guarantee that the subclass overrides the required methods.\n\n```java\npublic DefaultPrettyPrinter createInstance() {\n    if (!(this instanceof DefaultPrettyPrinter)) {\n        throw new IllegalStateException(\"Subclass is not an instance of DefaultPrettyPrinter\");\n    }\n    return new DefaultPrettyPrinter(this);\n}\n```\n// Buggy Function\npublic DefaultPrettyPrinter createInstance() {\n    return new DefaultPrettyPrinter(this);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The `createInstance` method does not perform any checks on the subclass before creating a new instance of `DefaultPrettyPrinter`. This allows an invalid subclass to be used, leading to unexpected behavior.\nSuggestion: Check for Method Override\nCheck if the subclass overrides a certain method (e.g., `writeObject`) before creating a new instance. This can be done using reflection. This approach ensures that the subclass overrides the required method, making it a more robust solution.\n\n```java\npublic DefaultPrettyPrinter createInstance() {\n    try {\n        if (!getClass().getMethod(\"writeObject\", Object.class).getDeclaringClass().equals(getClass())) {\n            throw new IllegalStateException(\"Subclass does not override writeObject method\");\n        }\n    } catch (NoSuchMethodException e) {\n        throw new IllegalStateException(\"Subclass does not have writeObject method\");\n    }\n    return new DefaultPrettyPrinter(this);\n}\n```\n// Buggy Function\npublic DefaultPrettyPrinter createInstance() {\n    return new DefaultPrettyPrinter(this);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The `createInstance` method does not perform any checks on the subclass before creating a new instance of `DefaultPrettyPrinter`. This allows an invalid subclass to be used, leading to unexpected behavior.\nSuggestion: Use a Factory Method with Subclass Validation\nInstead of creating a new instance of `DefaultPrettyPrinter` directly, use a factory method that checks the validity of the subclass before creating a new instance. This approach provides a more flexible and maintainable solution.\n\n```java\nprivate DefaultPrettyPrinter createInstance(Class<?> clazz) {\n    if (!clazz.equals(DefaultPrettyPrinter.class) && !clazz.getSuperclass().equals(DefaultPrettyPrinter.class)) {\n        throw new IllegalStateException(\"Subclass is not a subclass of DefaultPrettyPrinter\");\n    }\n    try {\n        if (!clazz.getMethod(\"writeObject\", Object.class).getDeclaringClass().equals(clazz)) {\n            throw new IllegalStateException(\"Subclass does not override writeObject method\");\n        }\n    } catch (NoSuchMethodException e) {\n        throw new IllegalStateException(\"Subclass does not have writeObject method\");\n    }\n    return new DefaultPrettyPrinter(this);\n}\n\npublic DefaultPrettyPrinter createInstance() {\n    return createInstance(getClass());\n}\n```\n// Buggy Function\npublic DefaultPrettyPrinter createInstance() {\n    return new DefaultPrettyPrinter(this);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "public DefaultPrettyPrinter createInstance() {\n    if (this.getClass() == DefaultPrettyPrinter.class) {\n        throw new IllegalStateException(\"Subclass must override createInstance\");\n    }\n    return new DefaultPrettyPrinter(this);\n}",
      "public DefaultPrettyPrinter createInstance() {\n    try {\n        if (!getClass().getMethod(\"writeObject\", Object.class).getDeclaringClass().equals(getClass())) {\n            throw new IllegalStateException(\"Subclass does not override writeObject method\");\n        }\n    } catch (NoSuchMethodException e) {\n        throw new IllegalStateException(\"Subclass does not have writeObject method\");\n    }\n    return new DefaultPrettyPrinter(this);\n}",
      "public DefaultPrettyPrinter createInstance() {\n    return createInstance(getClass());\n}\n\nprivate DefaultPrettyPrinter createInstance(Class<?> clazz) {\n    if (!clazz.equals(DefaultPrettyPrinter.class) && !clazz.getSuperclass().equals(DefaultPrettyPrinter.class)) {\n        throw new IllegalStateException(\"Subclass is not a subclass of DefaultPrettyPrinter\");\n    }\n    try {\n        if (!clazz.getMethod(\"writeObject\", Object.class).getDeclaringClass().equals(clazz)) {\n            throw new IllegalStateException(\"Subclass does not override writeObject method\");\n        }\n    } catch (NoSuchMethodException e) {\n        throw new IllegalStateException(\"Subclass does not have writeObject method\");\n    }\n    try {\n        return clazz.getConstructor(DefaultPrettyPrinter.class).newInstance(this);\n    } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n        throw new IllegalStateException(\"Failed to create instance of subclass\", e);\n    }\n}"
    ]
  }
}