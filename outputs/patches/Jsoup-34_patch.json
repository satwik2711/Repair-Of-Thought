{
  "Jsoup-34": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function `nextIndexOf(CharSequence seq)` does not properly handle the case when the input sequence is not found in the remaining characters of the `input` array. Specifically, when the `offset` variable exceeds the length of the `input` array, the function still tries to access `input[i]` and `seq.charAt(j)`, leading to an `ArrayIndexOutOfBoundsException`. This issue is exacerbated by the fact that the function does not check if `i` or `j` exceeds the length of the `input` array or the `seq` sequence, respectively.\nSuggestion: Add Bounds Checking\nOne possible fix is to add bounds checking to ensure that `i` and `j` do not exceed the length of the `input` array and the `seq` sequence, respectively. We can add a simple check before accessing `input[i]` and `seq.charAt(j)` to ensure that they are within bounds. The modified code would look like this:\n```java\nint nextIndexOf(CharSequence seq) {\n    // ... (rest of the code remains the same)\n    for (int j = 1; i < last && j < seq.length() && i < length && seq.charAt(j) == input[i]; i++, j++) {\n        // ... (rest of the code remains the same)\n    }\n    return -1;\n}\n```\n// Buggy Function\nint nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function `nextIndexOf(CharSequence seq)` does not properly handle the case when the input sequence is not found in the remaining characters of the `input` array. Specifically, when the `offset` variable exceeds the length of the `input` array, the function still tries to access `input[i]` and `seq.charAt(j)`, leading to an `ArrayIndexOutOfBoundsException`. This issue is exacerbated by the fact that the function does not check if `i` or `j` exceeds the length of the `input` array or the `seq` sequence, respectively.\nSuggestion: Use a More Efficient Algorithm\nAnother possible fix is to use a more efficient algorithm that avoids the need for bounds checking. For example, we can use the Knuth-Morris-Pratt algorithm to search for the input sequence in the `input` array. This algorithm is more efficient and avoids the need for bounds checking. The modified code would look like this:\n```java\nint nextIndexOf(CharSequence seq) {\n    int[] lps = new int[seq.length()];\n    int j = 0;\n    for (int i = 1; i < seq.length(); i++) {\n        while (j > 0 && seq.charAt(j) != seq.charAt(i)) {\n            j = lps[j - 1];\n        }\n        if (seq.charAt(j) == seq.charAt(i)) {\n            j++;\n        }\n        lps[i] = j;\n    }\n    j = 0;\n    for (int i = pos; i < length; i++) {\n        while (j > 0 && seq.charAt(j) != input[i]) {\n            j = lps[j - 1];\n        }\n        if (seq.charAt(j) == input[i]) {\n            j++;\n        }\n        if (j == seq.length()) {\n            return i - seq.length() + 1 - pos;\n        }\n    }\n    return -1;\n}\n```\n// Buggy Function\nint nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function `nextIndexOf(CharSequence seq)` does not properly handle the case when the input sequence is not found in the remaining characters of the `input` array. Specifically, when the `offset` variable exceeds the length of the `input` array, the function still tries to access `input[i]` and `seq.charAt(j)`, leading to an `ArrayIndexOutOfBoundsException`. This issue is exacerbated by the fact that the function does not check if `i` or `j` exceeds the length of the `input` array or the `seq` sequence, respectively.\nSuggestion: Handle Edge Cases\nA third possible fix is to handle edge cases more explicitly. For example, we can add a check at the beginning of the function to return -1 immediately if the input sequence is empty or if the `input` array is empty. We can also add a check to return -1 if the `offset` variable exceeds the length of the `input` array. The modified code would look like this:\n```java\nint nextIndexOf(CharSequence seq) {\n    if (seq.length() == 0 || length == 0) {\n        return -1;\n    }\n    // ... (rest of the code remains the same)\n    if (offset >= length) {\n        return -1;\n    }\n    // ... (rest of the code remains the same)\n}\n```\n// Buggy Function\nint nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "int nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while (++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length) {\n            for (int j = 1; i < last && i < length && j < seq.length() && seq.charAt(j) == input[i]; i++, j++) {\n                // ... (rest of the code remains the same)\n            }\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}",
      "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]);\n        }\n        if (offset >= length) {\n            break;\n        }\n        if (offset + seq.length() > length) {\n            break;\n        }\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) {\n        }\n        if (i == last) {\n            return offset - pos;\n        }\n    }\n    return -1;\n}",
      "int nextIndexOf(CharSequence seq) {\n    if (seq.length() == 0 || length == 0) {\n        return -1;\n    }\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]);\n        }\n        if (offset + seq.length() > length) {\n            continue;\n        }\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) {\n        }\n        if (i == last) {\n            return offset - pos;\n        }\n    }\n    return -1;\n}"
    ]
  }
}