{
  "Closure-71": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function `checkPropertyVisibility` is not correctly handling the case where a private property is overridden with a non-private property in a different file. Specifically, the function is reporting an incorrect error type (`JSC_PRIVATE_OVERRIDE` instead of `JSC_BAD_PRIVATE_PROPERTY_ACCESS`) when it encounters this scenario.\nSuggestion: Correct Error Reporting Logic\nThe function `checkPropertyVisibility` should be modified to report an error of type `JSC_BAD_PRIVATE_PROPERTY_ACCESS` when it encounters a private property being overridden with a non-private property in a different file. This can be achieved by modifying the error reporting logic in the function to use the correct error type. The modified code would look like this:\n```java\nif (visibility == Visibility.PRIVATE && !sameInput) {\n    compiler.report(\n        t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n            objectType.toString()));\n}\n```\nThis change ensures that the correct error type is reported when a private property is overridden with a non-private property in a different file.\n// Buggy Function\nprivate void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function `checkPropertyVisibility` is not correctly handling the case where a private property is overridden with a non-private property in a different file. Specifically, the function is reporting an incorrect error type (`JSC_PRIVATE_OVERRIDE` instead of `JSC_BAD_PRIVATE_PROPERTY_ACCESS`) when it encounters this scenario.\nSuggestion: Add Additional Checks\nThe function `checkPropertyVisibility` should be modified to add additional checks to ensure that the correct error type is reported. For example, the function could check whether the property being accessed is a private property and whether it is being overridden with a non-private property in a different file. If both conditions are true, the function could report an error of type `JSC_BAD_PRIVATE_PROPERTY_ACCESS`. The modified code would look like this:\n```java\nif (visibility == Visibility.PRIVATE && !sameInput && parent.getType() == Token.ASSIGN) {\n    compiler.report(\n        t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n            objectType.toString()));\n}\n```\nThis change adds an additional check to ensure that the correct error type is reported when a private property is overridden with a non-private property in a different file.\n// Buggy Function\nprivate void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the function `checkPropertyVisibility` is not correctly handling the case where a private property is overridden with a non-private property in a different file. Specifically, the function is reporting an incorrect error type (`JSC_PRIVATE_OVERRIDE` instead of `JSC_BAD_PRIVATE_PROPERTY_ACCESS`) when it encounters this scenario.\nSuggestion: Modify Error Type in Specific Condition\nThe function `checkPropertyVisibility` should be modified to report an error of type `JSC_BAD_PRIVATE_PROPERTY_ACCESS` when a private property is overridden with a non-private property in a different file, and the parent node is an assignment node. The modified code would look like this:\n```java\nif (isOverride && visibility == Visibility.PRIVATE && !sameInput) {\n    compiler.report(\n        t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n            objectType.toString()));\n} else if (isOverride && visibility == Visibility.PRIVATE) {\n    compiler.report(\n        t.makeError(getprop, PRIVATE_OVERRIDE,\n            objectType.toString()));\n}\n```\nThis change modifies the error type reported by the function in a specific condition, ensuring that the correct error type is reported when a private property is overridden with a non-private property in a different file.\n// Buggy Function\nprivate void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}",
      "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        if (overridingVisibility != Visibility.PRIVATE) {\n          compiler.report(\n              t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n                  objectType.toString()));\n        } else {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  objectType.toString()));\n        }\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}",
      "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n\n  if (objectType != null) {\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}"
    ]
  }
}