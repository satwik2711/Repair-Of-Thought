{
  "Lang-31": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `containsAny` function is not correctly handling supplementary characters. In Java, supplementary characters are represented by two `char` values, known as a surrogate pair. The function is currently checking each character in the string individually, without considering the possibility that a character may be part of a surrogate pair. This means that the function is not correctly identifying supplementary characters, leading to incorrect results.\nSuggestion: Use Code Points Instead of Characters\nThis approach involves using the `codePointAt` method to get the code point of each character in the string, and then checking if the code point is present in the search array. This approach correctly handles supplementary characters, as it treats each code point as a single unit. The modified code would look like this:\n```java\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    for (int i = 0; i < csLength; ) {\n        int codePoint = cs.codePointAt(i);\n        for (char searchChar : searchChars) {\n            if (codePoint == searchChar) {\n                return true;\n            }\n        }\n        i += Character.charCount(codePoint);\n    }\n    return false;\n}\n```\n// Buggy Function\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tchar ch = cs.charAt(i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `containsAny` function is not correctly handling supplementary characters. In Java, supplementary characters are represented by two `char` values, known as a surrogate pair. The function is currently checking each character in the string individually, without considering the possibility that a character may be part of a surrogate pair. This means that the function is not correctly identifying supplementary characters, leading to incorrect results.\nSuggestion: Use a Surrogate Pair Detection Algorithm\nThis approach involves checking each character in the string to see if it is part of a surrogate pair, and if so, treating it as a single unit. This approach also correctly handles supplementary characters, as it identifies and treats them as single units. The modified code would look like this:\n```java\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    for (int i = 0; i < csLength; ) {\n        char ch = cs.charAt(i);\n        if (Character.isHighSurrogate(ch) && i + 1 < csLength) {\n            char lowSurrogate = cs.charAt(i + 1);\n            if (Character.isLowSurrogate(lowSurrogate)) {\n                int codePoint = Character.toCodePoint(ch, lowSurrogate);\n                for (char searchChar : searchChars) {\n                    if (codePoint == searchChar) {\n                        return true;\n                    }\n                }\n                i += 2;\n                continue;\n            }\n        }\n        for (char searchChar : searchChars) {\n            if (ch == searchChar) {\n                return true;\n            }\n        }\n        i++;\n    }\n    return false;\n}\n```\n// Buggy Function\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tchar ch = cs.charAt(i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `containsAny` function is not correctly handling supplementary characters. In Java, supplementary characters are represented by two `char` values, known as a surrogate pair. The function is currently checking each character in the string individually, without considering the possibility that a character may be part of a surrogate pair. This means that the function is not correctly identifying supplementary characters, leading to incorrect results.\nSuggestion: Use a Regular Expression\nThis approach involves using a regular expression to search for the presence of a character in the string. This approach correctly handles supplementary characters, as it uses a regular expression that is designed to handle them correctly. The modified code would look like this:\n```java\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    String regex = \"[\" + new String(searchChars) + \"]\";\n    return cs.toString().matches(\".*\" + regex + \".*\");\n}\n```\n// Buggy Function\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tchar ch = cs.charAt(i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "public static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    for (int i = 0; i < csLength; ) {\n        int codePoint = cs.codePointAt(i);\n        for (char searchChar : searchChars) {\n            if (codePoint == searchChar) {\n                return true;\n            }\n        }\n        i += Character.charCount(codePoint);\n    }\n    return false;\n}",
      "public static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    for (int i = 0; i < csLength; ) {\n        char ch = cs.charAt(i);\n        if (Character.isHighSurrogate(ch) && i + 1 < csLength) {\n            char lowSurrogate = cs.charAt(i + 1);\n            if (Character.isLowSurrogate(lowSurrogate)) {\n                int codePoint = Character.toCodePoint(ch, lowSurrogate);\n                for (char searchChar : searchChars) {\n                    if (codePoint == searchChar) {\n                        return true;\n                    }\n                }\n                i += 2;\n                continue;\n            }\n        }\n        for (char searchChar : searchChars) {\n            if (ch == searchChar) {\n                return true;\n            }\n        }\n        i++;\n    }\n    return false;\n}",
      "<think>\nOkay, I need to fix the containsAny function. The problem is that it doesn't handle supplementary characters correctly. Supplementary characters in Java are represented by two char values, a surrogate pair. The current code checks each char individually, so if a supplementary character is split across two indices, it won't be detected properly.\n\nThe suggestion is to use a regular expression. That makes sense because regex in Java can handle supplementary characters correctly when using the right pattern.\n\nLooking at the original code, it loops through each character in the CharSequence and each character in the searchChars array, checking for equality. But this approach fails when a character is a surrogate pair because each part is treated as a separate char.\n\nSo, the plan is to replace this nested loop with a regex check. How to do that?\n\nFirst, I'll create a regex pattern that matches any of the search characters. The pattern should be a character class, like [abc], where a, b, c are the search characters. Then, I'll check if the entire CharSequence matches a pattern that has any of these characters anywhere in it.\n\nWait, but how do I construct the regex correctly? I need to escape any special regex characters in the searchChars. For example, if a search character is a dot or a backslash, they have special meanings in regex and need to be escaped.\n\nSo, I should process each character in searchChars and escape them before building the regex. Alternatively, I can use Pattern.quote, but that might not be necessary if I'm building a character class. Hmm, but in a character class, some characters like ^, -, ], and \\ have special meanings. So, I need to make sure they are properly handled.\n\nWait, maybe using a regex isn't as straightforward as just concatenating the characters. For example, if a search character is a ']' or a '^', it could break the regex. So, I need to escape each character properly when building the regex.\n\nAlternatively, perhaps using a regex that uses the searchChars as a set, but ensuring that each character is treated literally. So, I can create a String that represents the character class by escaping each character.\n\nBut wait, in Java, the String constructor for a char array will correctly represent the characters, but when building a regex, certain characters need to be escaped.\n\nWait, perhaps a better approach is to use the Pattern class's quote method for each character, but that might not be efficient. Alternatively, I can manually escape each character.\n\nAlternatively, perhaps using the Apache Commons Lang's StringEscapeUtils.escapeRegex method would help, but I don't know if that's available here. Since the original code uses ArrayUtils from Apache Commons, maybe it's acceptable to use other utilities. But the original code doesn't import that, so perhaps it's better to avoid adding dependencies.\n\nSo, I'll proceed by manually escaping each character in the searchChars array when building the regex.\n\nWait, but how? Let me think about the regex character class. In a character class, the following have special meanings:\n\n- ^ at the beginning negates the class.\n- - indicates a range unless it's the first or last character.\n- ] ends the class unless escaped.\n\nSo, to include a literal ], it needs to be the first character after the opening [ or escaped.\n\nSo, for each character in searchChars, I need to check if it's one of these special characters and escape it with a backslash if necessary.\n\nBut wait, in Java strings, a backslash is represented by two backslashes. So, I need to add a backslash before each special character in the regex.\n\nAlternatively, perhaps using Pattern.quote for each character, but that would make each character a literal, which is what I want in the character class.\n\nWait, no. Pattern.quote returns a String that would match the literal character. So, for example, Pattern.quote(\"]\") would return \"\\Q]\\E\", which is a way to quote the character. But in a character class, I think that's not necessary. Hmm, maybe I'm overcomplicating.\n\nWait, perhaps the correct approach is to build the regex as a character class, and for each character in searchChars, add it to the class, properly escaping any characters that have special meaning in a regex character class.\n\nSo, let's outline the steps:\n\n1. Check if cs is empty or searchChars is empty. If so, return false.\n\n2. Build a regex pattern that matches any character in searchChars. The pattern should be something like \".*[characters].*\", where [characters] is the character class.\n\n3. To build the character class, iterate through each char in searchChars and append them to a string, escaping any necessary characters.\n\nWait, but how to handle surrogate pairs? Because in the regex, a single code point is treated as a single character, so if the searchChars include high and low surrogates, the regex should correctly match them as a single supplementary character.\n\nWait, but the way the regex is built, each char in searchChars is treated as a separate character. So, if a supplementary character is represented by two chars (a surrogate pair), then including both in the searchChars would cause the regex to match either of them, which might not be correct.\n\nWait, no. Because the original function is supposed to check if any of the characters in searchChars are present in cs. So, if a supplementary character is split into two chars in searchChars, then the function would return true if either of those chars is found in cs, which is incorrect because the presence of a single surrogate doesn't necessarily mean the supplementary character is present.\n\nWait, this is getting complicated. The original function's approach is incorrect because it doesn't handle surrogate pairs. The regex approach is supposed to fix that.\n\nWait, perhaps the regex approach is better because it treats the CharSequence as a sequence of Unicode code points, correctly handling supplementary characters as single units.\n\nSo, perhaps the correct approach is to convert the CharSequence into a String, then check if it contains any of the characters in the searchChars array, treating each search character as a Unicode code point.\n\nBut wait, the searchChars array is a char array, which can contain surrogate pairs. So, if a search character is a supplementary character, it's represented as two chars in the array. So, when building the regex, including those two chars would cause the regex to match either of them, which isn't correct because the supplementary character is a single code point.\n\nHmm, this is a problem. Because the searchChars array is a char array, it's possible that it contains surrogate pairs, which represent a single supplementary character. So, when building the regex, we need to treat each supplementary character as a single entity.\n\nWait, but the way the original function is written, it's checking each char in cs against each char in searchChars. So, if the searchChars array contains a surrogate pair (two chars), then the function would return true if either of those chars is found in cs, which is incorrect because the supplementary character is only present if both surrogates are present in the correct order.\n\nSo, the original function is flawed in that it can't correctly handle supplementary characters in the searchChars array.\n\nWait, but the root cause is that the function doesn't handle supplementary characters in the CharSequence cs. So, perhaps the regex approach will correctly handle that, but the searchChars may still have issues if they contain surrogate pairs.\n\nWait, perhaps the function's contract is that the searchChars are individual BMP characters, not supplementary. Or perhaps the function is intended to check for any of the chars in the array, regardless of whether they form a supplementary character.\n\nBut according to the problem statement, the issue is that the function doesn't handle supplementary characters in the CharSequence cs. So, the regex approach should fix that.\n\nSo, the plan is:\n\n- Convert the searchChars array into a regex character class, properly escaping any special regex characters.\n\n- Then, check if the CharSequence, when converted to a String, matches a regex that has any of those characters.\n\nSo, the steps in code:\n\n1. Check if cs is empty or searchChars is empty. Return false if so.\n\n2. Build a String from searchChars. But wait, if searchChars contains surrogate pairs, this would create a String with those surrogates, which may not form valid characters. So, perhaps this approach is incorrect.\n\nWait, perhaps the problem is that the original function is only supposed to check for the presence of any of the BMP characters in searchChars within the CharSequence. But supplementary characters in cs are not being detected because the function is checking each char individually, which may split a surrogate pair.\n\nSo, the regex approach should correctly detect whether any of the characters in the searchChars array appear in cs, considering each as a BMP character, and correctly handling when a supplementary character in cs is made up of two chars.\n\nWait, perhaps the regex approach is correct because it will treat the entire cs as a String and check for any occurrence of the characters in searchChars, regardless of whether they are part of a surrogate pair.\n\nWait, but in the regex, each character in the searchChars is treated as a separate possible match. So, if a supplementary character in cs is made up of two chars, and neither of those chars is in the searchChars, then the regex won't match. But if one of them is in searchChars, it would incorrectly return true.\n\nWait, that's a problem. Because the function is supposed to check if any of the characters in searchChars are present in cs. But if a supplementary character is present in cs, but its individual surrogates are not in searchChars, then the function should not return true. However, if the searchChars include a supplementary character, which is represented as two chars, then the regex would match either of those chars, leading to a false positive.\n\nWait, this suggests that the regex approach may not correctly handle supplementary characters in the searchChars array.\n\nHmm, this is getting complicated. Maybe I need to think differently.\n\nAlternative approach: Instead of using a regex, iterate through the code points of the CharSequence and check if any of them are present in the searchChars array. But to do that, I need to correctly handle code points, which may consist of one or two chars.\n\nSo, the steps would be:\n\n1. Convert the searchChars array into a set of code points. But wait, each char in the array is a 16-bit value, which could be a BMP character or a surrogate. So, if the array contains a high surrogate followed by a low surrogate, together they form a supplementary character. So, the set should contain the code points of each individual char, as well as any supplementary characters formed by pairs.\n\nWait, but that's not straightforward. Because the searchChars array is a char array, each element is a single 16-bit char. So, if the array contains surrogate pairs, they are treated as two separate chars. So, the function is supposed to check if any of the chars in the array are present in the CharSequence. So, if a supplementary character is in the searchChars array, it's represented as two chars, and the function would return true if either of those chars is found in cs.\n\nBut that's incorrect because the supplementary character is only present if both surrogates are present in order. So, the function's current approach is incorrect in that it can't detect supplementary characters in cs, but also, if the searchChars include surrogate pairs, it may incorrectly return true when only one surrogate is present.\n\nWait, but according to the problem statement, the root cause is that the function doesn't handle supplementary characters in cs correctly. So, the fix is to correctly detect when a supplementary character is present in cs, regardless of whether the searchChars include surrogate pairs.\n\nSo, perhaps the regex approach is still the way to go, but I need to ensure that the regex correctly matches any of the searchChars as individual chars, and that the function correctly handles supplementary characters in cs.\n\nWait, perhaps the regex approach is correct because when you create a regex pattern like [abc], it matches any of the characters a, b, or c, regardless of whether they are part of a surrogate pair in the string. So, if the string contains a supplementary character, which is two chars, but neither of those chars is in the searchChars, the regex won't match. If the string contains a supplementary character, and one of its surrogates is in the searchChars, the regex will match, which is incorrect because the supplementary character isn't in the searchChars.\n\nWait, that's a problem. Because the function is supposed to return true only if any of the characters in the searchChars are present in the string. So, if the string contains a supplementary character that's not in the searchChars, but one of its surrogates is in the searchChars, the function would incorrectly return true.\n\nSo, the regex approach may not be the correct solution because it can't distinguish between individual surrogates and the actual supplementary characters.\n\nHmm, this is getting tricky. Maybe the correct approach is to iterate through the code points of the CharSequence and check if any of them are present in the searchChars array, treating each code point as a single unit.\n\nSo, how can I do that?\n\nIn Java, you can get the code points of a CharSequence using the codePointAt and codePointBefore methods, along with the offsetByCodePoints method.\n\nSo, the plan is:\n\n1. Check if cs is empty or searchChars is empty. Return false.\n\n2. Convert the searchChars array into a set of integers, where each integer is the code point of each char in the array. Wait, but each char is 16 bits, so for BMP characters, it's their code point. For surrogates, they are treated as individual code points, which is incorrect because they don't form valid characters on their own.\n\nWait, but the function's contract is to check if any of the chars in searchChars are present in cs. So, if a surrogate is present in searchChars, the function should return true if that surrogate is found in cs, regardless of whether it's part of a supplementary character.\n\nSo, perhaps the function is intended to check for the presence of any of the individual chars in searchChars, regardless of whether they form part of a supplementary character.\n\nIn that case, the original function is incorrect because it doesn't handle supplementary characters in cs correctly. For example, if cs contains a supplementary character, which is two chars, and neither of those chars is in searchChars, the function correctly returns false. But if one of the surrogates is in searchChars, the function would return true, which is correct according to the function's contract.\n\nWait, no. Because the function's contract is to check if any of the searchChars are present in cs. So, if a surrogate is in searchChars, and cs contains that surrogate as part of a supplementary character, then the function should return true, which is correct.\n\nSo, the issue is that the original function doesn't correctly handle supplementary characters in cs, meaning that if a supplementary character is present in cs, but the function doesn't detect it because it's split across two chars, which are not in the searchChars.\n\nWait, no. The function is supposed to return true if any of the chars in searchChars are present in cs. So, if a supplementary character is present in cs, but none of its surrogates are in searchChars, the function correctly returns false. If one of the surrogates is in searchChars, it returns true, which is correct.\n\nSo, the problem arises when a supplementary character is present in cs, but the function doesn't detect it because it's checking each char individually. Wait, no, because the supplementary character is made of two chars, so if neither of those chars is in searchChars, the function correctly returns false. But if the supplementary character is in the searchChars, which is represented as two chars, then the function would check each of those two chars against the cs, which may contain the supplementary character, thus returning true.\n\nWait, I'm getting confused. Let me think with an example.\n\nSuppose cs is a string containing the supplementary character U+1F600 (grinning face), which is represented as two chars: a high surrogate and a low surrogate.\n\nSuppose searchChars contains the two surrogates (as individual chars). Then, the original function would loop through each char in cs, which are the two surrogates, and check against each char in searchChars. So, if the searchChars include either surrogate, the function would return true, which is correct.\n\nBut if the searchChars don't include either surrogate, the function correctly returns false.\n\nWait, but the problem is that the original function doesn't handle supplementary characters in cs correctly. So, perhaps the issue is that when a supplementary character is present in cs, but the function is looking for a BMP character that is part of that supplementary character, it doesn't find it.\n\nWait, no. Because the supplementary character is two chars, and the function is checking each char in cs against each char in searchChars. So, if the searchChars include a BMP character that is part of a supplementary character in cs, the function would not find it because the supplementary character's code point is different from the BMP character.\n\nWait, perhaps the issue is that the function is supposed to check for the presence of any of the searchChars as Unicode code points, not as individual chars. So, if a supplementary character is present in cs, and the searchChars include that supplementary character (as two chars), the function should return true. But the original function would not, because it's checking each char individually.\n\nWait, no. Because the searchChars array is a char array, each element is a 16-bit char. So, a supplementary character can't be directly stored in the array; it's represented as two separate chars. So, the function is supposed to return true if any of the individual chars in the searchChars array are present in the cs.\n\nSo, the original function is correct in that sense, except when the cs contains a supplementary character, and the function is looking for a BMP character that is part of that supplementary character. Wait, no, because the supplementary character's code point is different from the BMP character.\n\nI'm getting stuck here. Let me go back to the problem statement.\n\nThe root cause is that the function doesn't handle supplementary characters in cs. So, when cs contains a supplementary character, the function may not detect it correctly because it's split into two chars.\n\nWait, but the function is supposed to check if any of the chars in searchChars are present in cs. So, if a supplementary character is in cs, but none of its surrogates are in searchChars, the function correctly returns false. If one of the surrogates is in searchChars, it returns true, which is correct.\n\nSo, the problem must be that when a supplementary character is present in cs, and the searchChars include the code point of that supplementary character, the function doesn't detect it because it's checking each char individually.\n\nWait, but the searchChars array is a char array, so it can't contain the supplementary character's code point directly. It can only contain the individual surrogates.\n\nSo, perhaps the function is supposed to check for the presence of any of the code points in the searchChars array, treating each as a code point, not as individual chars.\n\nWait, but that's not possible because a char in Java is 16 bits, which can only represent BMP characters or surrogates.\n\nSo, perhaps the function is intended to check for the presence of any of the code points represented by the searchChars array. So, if the searchChars array contains a high surrogate followed by a low surrogate, together they form a supplementary character, and the function should return true if that supplementary character is present in cs.\n\nBut the original function doesn't handle that because it's checking each char individually.\n\nSo, the correct approach is to:\n\n1. Iterate through each code point in cs.\n\n2. For each code point, check if it is present in the searchChars array as a code point.\n\nBut wait, the searchChars array is a char array, which can't directly represent code points beyond the BMP. So, perhaps the function is supposed to treat the searchChars array as a collection of code points, where each code point is either a single char (for BMP) or a pair of chars (for supplementary). But that complicates the function because it would require parsing the searchChars array into code points.\n\nThis seems complicated. Maybe the regex approach is better, but I need to ensure that the regex correctly matches the code points in the searchChars array.\n\nWait, perhaps the correct regex approach is to create a pattern that matches any of the code points in the searchChars array. So, each code point is represented as a Unicode escape in the regex.\n\nBut how to build that.\n\nAlternatively, perhaps the function should be rewritten to iterate through the code points of cs and check if any of them are present in the searchChars array, treating each code point as a single entity.\n\nSo, the steps would be:\n\n- Convert the searchChars array into a set of code points. But since the array is a char array, each element is a 16-bit value. So, for each char in the array, if it's a high surrogate, the next char should be a low surrogate, and together they form a supplementary code point. Otherwise, the char is a BMP code point.\n\nWait, but that would require processing the searchChars array as a sequence of code points, which may involve looking ahead to the next char if the current is a high surrogate.\n\nThis is getting quite involved. Let me outline the steps:\n\n1. Check if cs is empty or searchChars is empty. Return false.\n\n2. Convert the searchChars array into a set of code points. This involves iterating through the array and for each char:\n\n   a. If it's a high surrogate, check if the next char is a low surrogate. If so, combine them into a code point and add to the set.\n\n   b. If it's not a high surrogate, add its code point (which is its char value) to the set.\n\n3. Iterate through each code point in cs:\n\n   a. For each code point, check if it exists in the set created from searchChars.\n\n   b. If found, return true.\n\n4. If no code points match, return false.\n\nThis approach correctly handles supplementary characters in both cs and searchChars.\n\nBut implementing this requires writing code to process the searchChars array into code points and then checking each code point in cs against this set.\n\nThis seems more accurate but also more complex.\n\nGiven the time constraints, perhaps the regex approach is acceptable, but I need to ensure that it correctly handles supplementary characters in cs.\n\nWait, the regex approach as suggested in the fix uses a character class built from the searchChars array. So, if the searchChars array contains surrogate pairs, the regex would include those surrogates as individual characters, which may not be correct.\n\nBut according to the problem statement, the issue is that the function doesn't handle supplementary characters in cs. So, the regex approach would correctly detect if any of the searchChars are present in cs, treating each as individual chars, which is correct according to the function's contract.\n\nWait, but the function's contract is to check if any of the chars in the searchChars array are present in the CharSequence. So, if a supplementary character is present in cs, but none of its surrogates are in searchChars, the function correctly returns false. If one of the surrogates is in searchChars, it returns true, which is correct.\n\nSo, perhaps the regex approach is correct.\n\nBut then, how to build the regex correctly, ensuring that special regex characters are escaped.\n\nSo, in the fixed function, the code would be:\n\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    String regex = \"[\" + new String(searchChars) + \"]\";\n    return cs.toString().matches(\".*\" + regex + \".*\");\n}\n\nBut wait, this doesn't escape special regex characters. For example, if searchChars contains a '^' or ']', it would break the regex.\n\nSo, to fix that, each character in searchChars should be escaped before building the regex.\n\nSo, how to escape each character.\n\nI can create a method to escape each char:\n\nprivate static String escapeRegex(char c) {\n    switch (c) {\n        case '^':\n            return \"\\\\^\";\n        case '$':\n            return \"\\\\$\";\n        case '.':\n            return \"\\\\.\";\n        case '|':\n            return \"\\\\|\";\n        case '?':\n            return \"\\\\?\";"
    ]
  }
}