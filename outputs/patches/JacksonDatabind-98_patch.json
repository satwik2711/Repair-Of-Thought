{
  "JacksonDatabind-98": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `complete` function is not correctly handling the deserialization of the `AnimalAndType` object. Specifically, it is not correctly assigning the `type` property to the `AnimalAndType` object. This is because the `type` property is an enum value, and the function is not correctly converting the JSON string to the corresponding enum value.\nSuggestion: Use EnumDeserializer\nOne potential fix is to use an `EnumDeserializer` to deserialize the `type` property. We can create a custom `EnumDeserializer` that converts the JSON string to the corresponding enum value. We can then use this deserializer in the `complete` function to deserialize the `type` property. This approach requires creating a new class that extends `EnumDeserializer` and overrides the `deserialize` method to perform the conversion.\n// Buggy Function\npublic Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                buffer.assignParameter(typeProp, typeId);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `complete` function is not correctly handling the deserialization of the `AnimalAndType` object. Specifically, it is not correctly assigning the `type` property to the `AnimalAndType` object. This is because the `type` property is an enum value, and the function is not correctly converting the JSON string to the corresponding enum value.\nSuggestion: Use TypeConverter\nAnother potential fix is to use a `TypeConverter` to convert the JSON string to the corresponding enum value. We can create a custom `TypeConverter` that converts the JSON string to the corresponding enum value. We can then use this converter in the `complete` function to deserialize the `type` property. This approach requires creating a new class that implements `TypeConverter` and overrides the `convert` method to perform the conversion.\n// Buggy Function\npublic Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                buffer.assignParameter(typeProp, typeId);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `complete` function is not correctly handling the deserialization of the `AnimalAndType` object. Specifically, it is not correctly assigning the `type` property to the `AnimalAndType` object. This is because the `type` property is an enum value, and the function is not correctly converting the JSON string to the corresponding enum value.\nSuggestion: Modify complete Function\nA third potential fix is to modify the `complete` function to correctly handle the deserialization of the `AnimalAndType` object. We can add a check to see if the `type` property is an enum value, and if so, convert the JSON string to the corresponding enum value using the `findEnumType` method of the `DeserializationContext`. We can then assign the converted value to the `AnimalAndType` object. This approach requires modifying the existing code to add the necessary check and conversion.\n\nHere is the modified code for\n// Buggy Function\npublic Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                buffer.assignParameter(typeProp, typeId);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The root cause of the bug is that the `complete` function is not correctly handling the deserialization of the `AnimalAndType` object. Specifically, it is not correctly assigning the `type` property to the `AnimalAndType` object. This is because the `type` property is an enum value, and the function is not correctly converting the JSON string to the corresponding enum value.\nSuggestion: ```java\npublic Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // ...\n\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // ...\n        } else if (_tokens[i] == null) {\n            // ...\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // Check if type property is an enum value\n                if (typeProp.getType().isEnumType()) {\n                    // Convert JSON string to enum value\n                    Enum<?> enumValue = ctxt.findEnumType(typeProp.getType()).getEnumValues().get(typeId);\n                    buffer.assignParameter(typeProp, enumValue);\n                } else {\n                    buffer.assignParameter(typeProp, typeId);\n                }\n            }\n        }\n    }\n    // ...\n}\n```\n// Buggy Function\npublic Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                buffer.assignParameter(typeProp, typeId);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // Get the enum type from the type property\n                Class<Enum<?>> enumType = (Class<Enum<?>>) typeProp.getType();\n                // Deserialize the typeId to the corresponding enum value\n                Enum<?> enumValue = Enum.valueOf(enumType, typeId);\n                buffer.assignParameter(typeProp, enumValue);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}",
      "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                if (typeProp.getJavaType().isEnumType()) {\n                    JavaType type = typeProp.getJavaType();\n                    TypeConverter<Object> converter = ctxt.findTypeConverter(type);\n                    Object convertedTypeId = converter.convertFrom(typeId);\n                    buffer.assignParameter(typeProp, convertedTypeId);\n                } else {\n                    buffer.assignParameter(typeProp, typeId);\n                }\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}",
      "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        // Check if the property is an enum type and convert string to enum\n        JavaType propType = extProp.getJavaType();\n        if (propType != null && propType.isEnumType()) {\n            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) propType.getRawClass();\n            String valueStr = (String) values[i];\n            values[i] = Enum.valueOf(enumClass, valueStr);\n        }\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                //    apply deserializer... fun fun.\n                buffer.assignParameter(typeProp, typeId);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}",
      "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    // first things first: deserialize all data buffered:\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            // let's allow missing both type and property (may already have been set, too)\n            if (_tokens[i] == null) {\n                continue;\n            }\n            // but not just one\n            // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        // also: if it's creator prop, fill in\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            // [databind#999] And maybe there's creator property for type id too?\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            // for now, should only be needed for creator properties, too\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // Check if type property is an enum value\n                if (typeProp.getType().isEnumType()) {\n                    // Convert JSON string to enum value\n                    Enum<?> enumValue = ctxt.findEnumType(typeProp.getType()).getEnumValues().get(typeId);\n                    buffer.assignParameter(typeProp, enumValue);\n                } else {\n                    buffer.assignParameter(typeProp, typeId);\n                }\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    // third: assign non-creator properties\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}"
    ]
  }
}