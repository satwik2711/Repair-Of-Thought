{
  "Closure-32": {
    "prompt": [
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The issue lies in the way the function handles whitespace and line breaks. Specifically, when the `option` parameter is set to `PRESERVE`, the function trims the extracted text, which removes the leading whitespace on each line. However, the expected result in the trigger test includes this whitespace. Additionally, the function appends a space before each line break, which is not present in the expected result.\nSuggestion: Modify the trimming logic\nModify the trimming logic to only remove trailing whitespace when the `option` parameter is set to `PRESERVE`. This can be achieved by replacing the `trim()` method with a custom implementation that only removes trailing whitespace. For example, you can use the `replaceFirst()` method to remove the trailing whitespace:\n```java\nif (option != WhitespaceOption.PRESERVE) {\n    line = line.replaceFirst(\"\\\\s+$\", \"\");\n}\n```\nThis will ensure that the leading whitespace is preserved, and only the trailing whitespace is removed.\n// Buggy Function\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String line = stream.getRemainingJSDocLine();\n  if (option != WhitespaceOption.PRESERVE) {\n    line = line.trim();\n  }\n\n  StringBuilder builder = new StringBuilder();\n  builder.append(line);\n\n  state = State.SEARCHING_ANNOTATION;\n  token = next();\n\n  boolean ignoreStar = false;\n\n  // Track the start of the line to count whitespace that\n  // the tokenizer skipped. Because this case is rare, it's easier\n  // to do this here than in the tokenizer.\n\n  do {\n    switch (token) {\n      case STAR:\n        if (ignoreStar) {\n          // Mark the position after the star as the new start of the line.\n        } else {\n          // The star is part of the comment.\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append('*');\n        }\n\n        token = next();\n        continue;\n\n      case EOL:\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n\n        ignoreStar = true;\n        token = next();\n        continue;\n\n      default:\n        ignoreStar = false;\n        state = State.SEARCHING_ANNOTATION;\n\n            // All tokens must be separated by a space.\n\n        if (token == JsDocToken.EOC ||\n            token == JsDocToken.EOF ||\n            // When we're capturing a license block, annotations\n            // in the block are ok.\n            (token == JsDocToken.ANNOTATION &&\n             option != WhitespaceOption.PRESERVE)) {\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n        }\n\n        if (builder.length() > 0) {\n          builder.append(' ');\n        }\n        builder.append(toString(token));\n\n        line = stream.getRemainingJSDocLine();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          line = trimEnd(line);\n        }\n\n        builder.append(line);\n        token = next();\n    }\n  } while (true);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The issue lies in the way the function handles whitespace and line breaks. Specifically, when the `option` parameter is set to `PRESERVE`, the function trims the extracted text, which removes the leading whitespace on each line. However, the expected result in the trigger test includes this whitespace. Additionally, the function appends a space before each line break, which is not present in the expected result.\nSuggestion: Remove the extra space before line breaks\nRemove the extra space that is appended before each line break when the `option` parameter is set to `PRESERVE`. This can be achieved by modifying the line `builder.append(' ');` to only append a space when necessary. For example, you can add a conditional statement to check if the `option` parameter is set to `PRESERVE` before appending the space:\n```java\nif (option != WhitespaceOption.PRESERVE) {\n    builder.append(' ');\n}\n```\nThis will ensure that the extra space is not appended before each line break when the `option` parameter is set to `PRESERVE`.\n// Buggy Function\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String line = stream.getRemainingJSDocLine();\n  if (option != WhitespaceOption.PRESERVE) {\n    line = line.trim();\n  }\n\n  StringBuilder builder = new StringBuilder();\n  builder.append(line);\n\n  state = State.SEARCHING_ANNOTATION;\n  token = next();\n\n  boolean ignoreStar = false;\n\n  // Track the start of the line to count whitespace that\n  // the tokenizer skipped. Because this case is rare, it's easier\n  // to do this here than in the tokenizer.\n\n  do {\n    switch (token) {\n      case STAR:\n        if (ignoreStar) {\n          // Mark the position after the star as the new start of the line.\n        } else {\n          // The star is part of the comment.\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append('*');\n        }\n\n        token = next();\n        continue;\n\n      case EOL:\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n\n        ignoreStar = true;\n        token = next();\n        continue;\n\n      default:\n        ignoreStar = false;\n        state = State.SEARCHING_ANNOTATION;\n\n            // All tokens must be separated by a space.\n\n        if (token == JsDocToken.EOC ||\n            token == JsDocToken.EOF ||\n            // When we're capturing a license block, annotations\n            // in the block are ok.\n            (token == JsDocToken.ANNOTATION &&\n             option != WhitespaceOption.PRESERVE)) {\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n        }\n\n        if (builder.length() > 0) {\n          builder.append(' ');\n        }\n        builder.append(toString(token));\n\n        line = stream.getRemainingJSDocLine();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          line = trimEnd(line);\n        }\n\n        builder.append(line);\n        token = next();\n    }\n  } while (true);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible.",
      "You are a Senior Level Programmer with expertise in debugging and code repair. Your task is to review the provided function and produce a corrected, function-level implementation that fully addresses the identified bug.\n\n@@ Context\n// Provide a fix for the buggy function.\nRoot cause: The issue lies in the way the function handles whitespace and line breaks. Specifically, when the `option` parameter is set to `PRESERVE`, the function trims the extracted text, which removes the leading whitespace on each line. However, the expected result in the trigger test includes this whitespace. Additionally, the function appends a space before each line break, which is not present in the expected result.\nSuggestion: Use a different approach to handle whitespace\nInstead of using the `trim()` method, use a different approach to handle whitespace, such as using a regular expression to remove leading and trailing whitespace. This can provide more flexibility and accuracy in handling whitespace. For example, you can use the `replaceAll()` method to remove the leading and trailing whitespace:\n```java\nif (option != WhitespaceOption.PRESERVE) {\n    line = line.replaceAll(\"^\\\\s+|\\\\s+$\", \"\");\n}\n```\nThis will ensure that the leading and trailing whitespace is removed, while preserving the whitespace within the text.\n// Buggy Function\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String line = stream.getRemainingJSDocLine();\n  if (option != WhitespaceOption.PRESERVE) {\n    line = line.trim();\n  }\n\n  StringBuilder builder = new StringBuilder();\n  builder.append(line);\n\n  state = State.SEARCHING_ANNOTATION;\n  token = next();\n\n  boolean ignoreStar = false;\n\n  // Track the start of the line to count whitespace that\n  // the tokenizer skipped. Because this case is rare, it's easier\n  // to do this here than in the tokenizer.\n\n  do {\n    switch (token) {\n      case STAR:\n        if (ignoreStar) {\n          // Mark the position after the star as the new start of the line.\n        } else {\n          // The star is part of the comment.\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append('*');\n        }\n\n        token = next();\n        continue;\n\n      case EOL:\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n\n        ignoreStar = true;\n        token = next();\n        continue;\n\n      default:\n        ignoreStar = false;\n        state = State.SEARCHING_ANNOTATION;\n\n            // All tokens must be separated by a space.\n\n        if (token == JsDocToken.EOC ||\n            token == JsDocToken.EOF ||\n            // When we're capturing a license block, annotations\n            // in the block are ok.\n            (token == JsDocToken.ANNOTATION &&\n             option != WhitespaceOption.PRESERVE)) {\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n        }\n\n        if (builder.length() > 0) {\n          builder.append(' ');\n        }\n        builder.append(toString(token));\n\n        line = stream.getRemainingJSDocLine();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          line = trimEnd(line);\n        }\n\n        builder.append(line);\n        token = next();\n    }\n  } while (true);\n}\n// Fixed Function\n\n@@ Instructions\n1. Carefully analyze the provided root cause and fix suggestion.\n2. Ensure your implementation completely resolves the identified issue.\n3. Maintain the original method signature.\n4. Preserve the original functionality and coding style as much as possible.\n5. Incorporate all working parts of the original implementation.\n6. Follow the provided fix suggestion without over-engineering or introducing unnecessary changes.\n\n@@ Response Format\nReturn ONLY the complete fixed function wrapped in ```java\n<your implementation>\n``` tags.\n\n@@ Important Notes\n- Do not add unnecessary optimizations.\n- Do not modify the method signature.\n- Maintain the original variable names and overall coding style wherever possible."
    ],
    "patches": [
      "<think>\nOkay, so I need to fix this Java function called extractMultilineTextualBlock. The problem is that when the option is set to PRESERVE, the function trims the text in a way that removes leading whitespace, which isn't desired. Also, it's adding a space before line breaks, which isn't correct either.\n\nLet me look at the code. The function starts by checking if the token is EOC, EOL, or EOF. If so, it returns an ExtractionInfo with an empty string. Then it reads the content from the first line using stream.getRemainingJSDocLine(). \n\nHere's the first issue: after getting the line, if the option isn't PRESERVE, it trims the line. But when option is PRESERVE, it should only remove trailing whitespace, not leading. So the initial line trimming is wrong for PRESERVE.\n\nThen, it appends this line to a StringBuilder. Next, it enters a loop where it processes tokens. When it encounters a STAR, it appends a '*' and a space if needed. For EOL, it appends a newline if the option isn't SINGLE_LINE. But wait, in the original code, when EOL is processed, it appends \"\\n\" and then sets ignoreStar to true. \n\nLooking further down, when the token is not EOC, EOF, or ANNOTATION (depending on the option), it processes the token. It appends a space if the builder isn't empty, then appends the token's string. Then it gets the remaining line again, and if the option isn't PRESERVE, it trims the end. But wait, the code uses trimEnd(line), which only removes trailing whitespace. But earlier, the initial line was trimmed with line.trim(), which removes both leading and trailing.\n\nSo the first problem is that when option is PRESERVE, the initial line is still being trimmed, which removes leading whitespace. That's incorrect. So I need to modify the trimming logic.\n\nThe suggestion was to replace the trim() with a custom implementation that only removes trailing whitespace. So in the initial line processing, instead of line.trim(), we should do something else when option is PRESERVE.\n\nWait, no. The initial code says if option is not PRESERVE, then line = line.trim(). So for PRESERVE, it doesn't trim. But the problem arises when the option is PRESERVE, because the code later appends lines with line = stream.getRemainingJSDocLine(), and then if option is not PRESERVE, it trims the end. But for PRESERVE, it doesn't, so the trailing whitespace is kept. But the initial line might have leading whitespace that should be preserved.\n\nWait, the initial line is read and only trimmed if option is not PRESERVE. So for PRESERVE, the initial line is not trimmed, which is correct. But the problem is that in the loop, when processing each subsequent line, it appends the line after trimming the end only if option is not PRESERVE. So for PRESERVE, it appends the line as is, which includes leading and trailing whitespace. But according to the problem, the function is trimming the extracted text when it shouldn't, removing leading whitespace on each line.\n\nWait, maybe I'm misunderstanding. Let me re-read the root cause. The issue is that when option is PRESERVE, the function trims the extracted text, removing leading whitespace on each line. But the expected result includes this whitespace. Also, it appends a space before each line break, which isn't present in the expected result.\n\nSo looking at the code, when option is PRESERVE, the initial line is not trimmed, which is correct. But in the loop, each subsequent line is read, and if option is not PRESERVE, it trims the end. But for PRESERVE, it appends the line as is. So that part is okay.\n\nWait, but the problem says that the function trims the extracted text when option is PRESERVE, which removes leading whitespace. So perhaps the initial line is being trimmed even when option is PRESERVE. Let me check.\n\nNo, the initial line is only trimmed if option is not PRESERVE. So that's correct. So maybe the problem is elsewhere.\n\nWait, perhaps in the loop, when the token is EOL, the code appends a \"\\n\" and then ignores the star. But when the next line is read, it's possible that the leading whitespace is being lost.\n\nAlternatively, perhaps the issue is that when the option is PRESERVE, the code is trimming the entire multilineText at the end. Let me look at that part.\n\nAfter processing all tokens, when it's time to return, the code does:\n\nif (option != WhitespaceOption.PRESERVE) {\n    multilineText = multilineText.trim();\n}\n\nSo for PRESERVE, it doesn't trim, which is correct. But wait, the initial line is not trimmed, but the code appends each subsequent line without trimming, so leading whitespace should be preserved.\n\nHmm, maybe the problem is that when the option is PRESERVE, the code is still trimming the end of each line in the loop. Let me check.\n\nIn the loop, after getting the line, it does:\n\nif (option != WhitespaceOption.PRESERVE) {\n    line = trimEnd(line);\n}\n\nSo for PRESERVE, it doesn't trim the end. So trailing whitespace is preserved. But the problem says that the function trims the extracted text, removing leading whitespace on each line. So perhaps the initial line is being handled correctly, but the subsequent lines are being handled incorrectly.\n\nWait, no. The initial line is read once, and then in the loop, each EOL causes the next line to be read. So for each line after the first, the code appends a space and then the line, which may include leading whitespace.\n\nWait, no. Let me see: in the loop, when the token is EOL, it appends a \"\\n\" (if option isn't SINGLE_LINE), sets ignoreStar to true, and then reads the next token. Then, when processing the next token, which is likely the next line's content, it appends a space if the builder isn't empty, then appends the token's string, then appends the line (after possibly trimming the end).\n\nWait, perhaps the issue is that when the option is PRESERVE, the code is adding a space before the line, which is causing leading whitespace to be lost or altered.\n\nWait, let's think about how the lines are built. The first line is read and added to the builder. Then, for each EOL, a newline is added. Then, the next line is read, and if the option is not PRESERVE, the end is trimmed. But for PRESERVE, the line is added as is. However, before adding the line, the code appends a space if the builder isn't empty. So for the first line, the builder has content, so when the next line is processed, it appends a space, then the next line's content.\n\nWait, that's a problem. Because in the case of a multiline block, each new line should start on a new line without adding a space before. For example, if the first line is \"  Hello\", and the second line is \"World\", the result should be \"  Hello\\nWorld\", but the code is appending a space before the second line, making it \"  Hello World\" on the first line, and then \"\\nWorld\" on the next. Or perhaps I'm misunderstanding.\n\nWait, no. Let me look at the code again. After processing EOL, it appends a \"\\n\" to the builder. Then, when the next token is processed, it's likely a new line. The code appends a space if the builder isn't empty, then appends the token's string, then appends the line.\n\nWait, perhaps the space is being added incorrectly. For example, after a newline, the next line should not have a leading space added by the code. So the code is adding a space before appending the next line's content, which is incorrect.\n\nLooking at the code:\n\nIn the default case, after processing a token, it checks if the builder isn't empty, and appends a space. Then appends the token's string. Then appends the line.\n\nWait, no. Let me see:\n\nIn the default case, it appends the token's string, then gets the remaining line, trims the end if needed, and appends that line. So for example, if the token is a word, it appends a space and the word, then appends the rest of the line.\n\nBut when the next line starts after an EOL, the code appends a \"\\n\", then in the next iteration, processes the next token, which is the start of the next line. At that point, the code appends a space if the builder isn't empty, which it is because we just added a \"\\n\". So it appends a space, then the token's string, then the line.\n\nWait, that would mean that after a newline, the next line starts with a space, which is not desired. So for example, if the lines are:\n\n  Line one\n  Line two\n\nThe code would produce \"Line one Line two\" when option is not PRESERVE, but when PRESERVE is set, it would have \"  Line one \\n Line two\", which is incorrect because of the space after the newline.\n\nSo the issue is that after a newline, the code is adding a space before the next line's content, which is wrong. The space should not be added in that case.\n\nSo how to fix this? We need to avoid adding a space after a newline.\n\nLooking at the code, after an EOL, the code appends a \"\\n\" and sets ignoreStar to true. Then, the next token is processed. At that point, the code checks if the builder isn't empty and appends a space. But after a newline, the builder ends with \"\\n\", so the next append should not add a space.\n\nSo perhaps we need to track whether the previous character was a newline, and if so, not add a space.\n\nAlternatively, in the code, after appending a \"\\n\", the next token processing should not add a space.\n\nHmm, perhaps the condition for appending a space should be adjusted. Currently, it appends a space if the builder's length is greater than 0. But after a newline, the builder's length is greater than 0, so it appends a space, which is incorrect.\n\nSo maybe the condition should be more nuanced. For example, only append a space if the last character isn't a newline.\n\nBut how can we check that? Well, perhaps we can track whether the last character was a newline. Alternatively, we can check if the builder ends with a newline before appending a space.\n\nSo in the default case, before appending a space, we can check if the last character is not a newline.\n\nLet me think about how to implement that. So, in the default case:\n\nif (builder.length() > 0) {\n    // Check if the last character is not a newline\n    if (builder.charAt(builder.length() - 1) != '\\n') {\n        builder.append(' ');\n    }\n}\nbuilder.append(toString(token));\n\nThis way, after a newline, we don't add a space before the next token.\n\nBut wait, in the case where the next token is on the same line, we do want to add a space. So this adjustment should fix the issue where a space is added after a newline.\n\nAnother approach is to set a flag indicating whether the previous token was an EOL. So when processing the next token after EOL, we know not to add a space.\n\nAlternatively, perhaps the code should not append a space when the previous character is a newline.\n\nSo, in the code, in the default case, before appending a space, check if the last character is a newline. If it is, don't append a space.\n\nSo, modifying that part of the code.\n\nAdditionally, the initial trimming of the line when option is not PRESERVE is incorrect because it trims leading whitespace. So, as per the suggestion, we should replace the trim() with a method that only trims trailing whitespace.\n\nWait, the initial line is read and trimmed only if option is not PRESERVE. So for option PRESERVE, the initial line is not trimmed, which is correct. But for other options, it's trimmed, which removes leading and trailing whitespace. But according to the problem, when option is PRESERVE, the leading whitespace should be preserved, which it is because we don't trim. However, the problem arises when the option is PRESERVE, and the code is still trimming the lines in some way.\n\nWait, perhaps the issue is that in the loop, each line is being trimmed on the end when option is not PRESERVE, but for PRESERVE, it's not. So that part is correct.\n\nWait, but the problem says that when option is PRESERVE, the function trims the extracted text, removing leading whitespace on each line. So perhaps the initial line is being handled correctly, but the subsequent lines are being handled incorrectly.\n\nWait, no. Let me think again. The initial line is read and only trimmed if option is not PRESERVE. So for PRESERVE, the initial line is kept as is, including leading whitespace. Then, in the loop, each subsequent line is read, and if option is not PRESERVE, the end is trimmed. But for PRESERVE, the line is added as is. So the leading whitespace of each subsequent line is preserved.\n\nBut the problem says that the function is trimming the extracted text, removing leading whitespace on each line. So perhaps the code is incorrectly trimming the lines even when option is PRESERVE.\n\nWait, no. Because in the loop, the code only trims the end if option is not PRESERVE. So for PRESERVE, the line is added without trimming. So leading whitespace is preserved.\n\nHmm, perhaps the problem is elsewhere. Maybe the issue is that when the option is PRESERVE, the code is still trimming the entire multilineText at the end. Let me check.\n\nAfter processing all tokens, the code does:\n\nif (option != WhitespaceOption.PRESERVE) {\n    multilineText = multilineText.trim();\n}\n\nSo for PRESERVE, it doesn't trim. So that's correct.\n\nWait, but the problem says that the function trims the extracted text, which suggests that for PRESERVE, it's being trimmed. So perhaps the initial line is being trimmed even when option is PRESERVE.\n\nWait, no. The initial line is only trimmed if option is not PRESERVE. So for PRESERVE, it's not trimmed.\n\nI'm a bit confused. Let me try to summarize the issues as per the root cause:\n\n1. When option is PRESERVE, the function trims the extracted text, removing leading whitespace on each line. Expected: leading whitespace is preserved.\n\n2. The function appends a space before each line break, which is not present in the expected result.\n\nSo, the first issue is that leading whitespace is being removed when it shouldn't. The second issue is an extra space before line breaks.\n\nSo, for the first issue, perhaps the code is trimming the initial line even when option is PRESERVE. But according to the code, it's not. So maybe the problem is in the way the lines are being appended.\n\nWait, perhaps the code is trimming each line in the loop when option is not PRESERVE, but for PRESERVE, it's not. So leading whitespace is preserved.\n\nBut the problem says that leading whitespace is being removed. So perhaps the initial line is being handled correctly, but the subsequent lines are being handled incorrectly.\n\nWait, no. Because in the loop, each line is read and, for PRESERVE, not trimmed. So leading whitespace is preserved.\n\nWait, perhaps the issue is that when the option is PRESERVE, the code is still trimming the end of each line, thus removing trailing whitespace, but the expected result requires trailing whitespace to be preserved as well. But according to the problem, the issue is leading whitespace, not trailing.\n\nAlternatively, perhaps the problem is that the initial line is being trimmed when option is not PRESERVE, but when option is PRESERVE, the initial line is not trimmed, which is correct.\n\nWait, perhaps the issue is that the code is trimming the end of each line even when option is PRESERVE, which would remove trailing whitespace. But according to the problem, the issue is leading whitespace, not trailing.\n\nHmm, perhaps I'm missing something. Let me think about the test case that's failing.\n\nSuppose the input is:\n\n/**\n *   Line one\n *   Line two\n */\n\nWhen option is PRESERVE, the expected output should be:\n\n\"  Line one\\n  Line two\"\n\nBut according to the function, perhaps it's returning \"Line one\\nLine two\" because it's trimming each line.\n\nWait, but according to the code, for the initial line, if option is PRESERVE, it's not trimmed. So the initial line would be \"  Line one\". Then, in the loop, after EOL, it appends \"\\n\", then reads the next line as \"  Line two\", and appends it without trimming, so the result would be \"  Line one\\n  Line two\".\n\nBut according to the problem, the function is trimming the extracted text, which removes leading whitespace. So perhaps the initial line is being trimmed even when option is PRESERVE.\n\nWait, no. The initial line is only trimmed if option is not PRESERVE. So for PRESERVE, it's not trimmed.\n\nWait, perhaps the code is using a different method to trim. Let me check the initial line processing:\n\nif (option != WhitespaceOption.PRESERVE) {\n    line = line.trim();\n}\n\nSo for PRESERVE, line remains as is.\n\nThen, the code appends line to the builder.\n\nSo the initial line's leading whitespace is preserved.\n\nThen, in the loop, each subsequent line is read, and if option is not PRESERVE, it's trimmed on the end. For PRESERVE, it's added as is.\n\nSo the leading whitespace of each line should be preserved.\n\nBut according to the problem, the function is removing leading whitespace on each line when option is PRESERVE.\n\nSo perhaps the issue is that the code is trimming the entire multilineText at the end when option is not PRESERVE, but that's correct.\n\nWait, perhaps the problem is that the code is trimming the end of each line when option is not PRESERVE, but that's intended. So I'm not seeing why leading whitespace is being removed.\n\nAlternatively, perhaps the issue is that the code is appending a space before each line, which is causing the leading whitespace to be lost.\n\nWait, let's think about the code flow. After the initial line is added, the code processes tokens. When it hits EOL, it appends a \"\\n\", then sets ignoreStar to true. Then, the next token is processed, which is the next line's content.\n\nAt that point, the code appends a space if the builder isn't empty, then appends the token's string, then appends the line.\n\nSo, for example, after the first line, the builder has \"  Line one\". Then, when EOL is processed, it appends \"\\n\", making the builder \"  Line one\\n\". Then, the next token is processed, which is the next line's content, say \"  Line two\".\n\nAt that point, the code checks if the builder isn't empty (which it is), so it appends a space, making it \"  Line one\\n \", then appends the token's string, which is \"Line\" (assuming the token is a word token), then appends the line, which is \" two\".\n\nWait, that can't be right. Because the token processing might be more granular. Alternatively, perhaps the token is the entire next line, so the code appends a space, then the entire line, leading to \"  Line one\\n  Line two\" becoming \"  Line one \\n  Line two\", which is incorrect because of the space before the newline.\n\nWait, no. Let me think again. After EOL, the builder has \"  Line one\\n\". Then, the next token is processed, which is the next line's starting token. The code appends a space because the builder isn't empty, resulting in \"  Line one\\n \", then appends the token's string, say \"Line\", making it \"  Line one\\n Line\", then appends the rest of the line, \" two\", making it \"  Line one\\n Line two\".\n\nBut the expected result is \"  Line one\\n  Line two\". So the space after the newline is incorrect.\n\nSo the issue is that the code is adding a space after the newline, which shouldn't be there.\n\nSo to fix this, we need to avoid adding a space after a newline.\n\nSo the solution is to modify the condition where the space is added. Instead of adding a space whenever the builder isn't empty, we should only add a space if the last character isn't a newline.\n\nSo in the default case, before appending a space, check if the last character is not a newline.\n\nSo, in code:\n\nif (builder.length() > 0) {\n    char lastChar = builder.charAt(builder.length() - 1);\n    if (lastChar != '\\n') {\n        builder.append(' ');\n    }\n}\n\nThis way, after a newline, we don't add a space.\n\nAdditionally, the initial trimming of the line when option is not PRESERVE is incorrect because it removes leading whitespace. So we need to replace the trim() with a method that only trims trailing whitespace.\n\nWait, the initial line is trimmed only if option is not PRESERVE. So for option PRESERVE, it's not trimmed, which is correct. But for other options, it's trimmed, which removes leading and trailing whitespace. However, according to the problem, when option is not PRESERVE, perhaps only trailing whitespace should be removed, not leading.\n\nWait, the problem says that when option is PRESERVE, leading whitespace is removed, which is incorrect. So perhaps the initial line's trimming is correct, but the way the lines are being appended is incorrect.\n\nWait, no. The initial line is only trimmed if option is not PRESERVE. So for option PRESERVE, leading whitespace is preserved. But according to the problem, when option is PRESERVE, the function trims the text, removing leading whitespace. So perhaps the initial line is being trimmed even when option is PRESERVE.\n\nWait, no. The code says if (option != WhitespaceOption.PRESERVE) { line = line.trim(); }, so for PRESERVE, it's not trimmed. So that's correct.\n\nSo the main issues are:\n\n1. After a newline, a space is being added before the next line's content.\n\n2. The initial line is being trimmed when option is not PRESERVE, which may remove leading whitespace that should be preserved in some cases.\n\nWait, no. The initial line is being trimmed when option is not PRESERVE, which is intended to remove both leading and trailing whitespace. But perhaps the desired behavior is to only remove trailing whitespace, not leading.\n\nSo, the initial line's trimming is incorrect for option not PRESERVE. Because it's using trim(), which removes both leading and trailing whitespace, but perhaps only trailing should be removed.\n\nSo the fix should address two things:\n\na) Modify the initial line trimming to only remove trailing whitespace when option is not PRESERVE.\n\nb) Prevent adding a space after a newline.\n\nSo, for part a), in the initial line processing, instead of line.trim(), we should trim only the trailing whitespace.\n\nSimilarly, in the loop, when processing each line, we should trim only the trailing whitespace when option is not PRESERVE.\n\nSo, the code currently uses line.trim() for the initial line, which is incorrect. It should be replaced with a method that trims only trailing whitespace.\n\nThe suggestion provided was to use line.replaceFirst(\"\\\\s+$\", \"\") to remove trailing whitespace.\n\nSo, in the initial line processing, instead of line.trim(), we can do:\n\nif (option != WhitespaceOption.PRESERVE) {\n    line = line.replaceFirst(\"\\\\s+$\", \"\");\n}\n\nSimilarly, in the loop, when processing each line, instead of line = trimEnd(line), which I assume does the same, perhaps it's better to use the same approach.\n\nWait, looking at the code, in the loop, after getting the line, it does:\n\nif (option != WhitespaceOption.PRESERVE) {\n    line = trimEnd(line);\n}\n\nBut what is",
      "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String line = stream.getRemainingJSDocLine();\n  if (option != WhitespaceOption.PRESERVE) {\n    line = line.trim();\n  }\n\n  StringBuilder builder = new StringBuilder();\n  builder.append(line);\n\n  state = State.SEARCHING_ANNOTATION;\n  token = next();\n\n  boolean ignoreStar = false;\n\n  // Track the start of the line to count whitespace that\n  // the tokenizer skipped. Because this case is rare, it's easier\n  // to do this here than in the tokenizer.\n\n  do {\n    switch (token) {\n      case STAR:\n        if (ignoreStar) {\n          // Mark the position after the star as the new start of the line.\n        } else {\n          // The star is part of the comment.\n          if (builder.length() > 0 && option != WhitespaceOption.PRESERVE) {\n            builder.append(' ');\n          }\n\n          builder.append('*');\n        }\n\n        token = next();\n        continue;\n\n      case EOL:\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n\n        ignoreStar = true;\n        token = next();\n        continue;\n\n      default:\n        ignoreStar = false;\n        state = State.SEARCHING_ANNOTATION;\n\n        // All tokens must be separated by a space.\n\n        if (token == JsDocToken.EOC ||\n            token == JsDocToken.EOF ||\n            // When we're capturing a license block, annotations\n            // in the block are ok.\n            (token == JsDocToken.ANNOTATION &&\n             option != WhitespaceOption.PRESERVE)) {\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n        }\n\n        if (builder.length() > 0 && option != WhitespaceOption.PRESERVE) {\n          builder.append(' ');\n        }\n        builder.append(toString(token));\n\n        line = stream.getRemainingJSDocLine();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          line = trimEnd(line);\n        }\n\n        builder.append(line);\n        token = next();\n    }\n  } while (true);\n}",
      "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String line = stream.getRemainingJSDocLine();\n  if (option != WhitespaceOption.PRESERVE) {\n    line = line.replaceAll(\"^\\\\s+|\\\\s+$\", \"\");\n  }\n\n  StringBuilder builder = new StringBuilder();\n  builder.append(line);\n\n  state = State.SEARCHING_ANNOTATION;\n  token = next();\n\n  boolean ignoreStar = false;\n\n  // Track the start of the line to count whitespace that\n  // the tokenizer skipped. Because this case is rare, it's easier\n  // to do this here than in the tokenizer.\n\n  do {\n    switch (token) {\n      case STAR:\n        if (ignoreStar) {\n          // Mark the position after the star as the new start of the line.\n        } else {\n          // The star is part of the comment.\n          if (builder.length() > 0 && option != WhitespaceOption.PRESERVE) {\n            builder.append(' ');\n          }\n\n          builder.append('*');\n        }\n\n        token = next();\n        continue;\n\n      case EOL:\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n\n        ignoreStar = true;\n        token = next();\n        continue;\n\n      default:\n        ignoreStar = false;\n        state = State.SEARCHING_ANNOTATION;\n\n            // All tokens must be separated by a space.\n\n        if (token == JsDocToken.EOC ||\n            token == JsDocToken.EOF ||\n            // When we're capturing a license block, annotations\n            // in the block are ok.\n            (token == JsDocToken.ANNOTATION &&\n             option != WhitespaceOption.PRESERVE)) {\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.replaceAll(\"^\\\\s+|\\\\s+$\", \"\");\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n        }\n\n        if (builder.length() > 0) {\n          builder.append(' ');\n        }\n        builder.append(toString(token));\n\n        line = stream.getRemainingJSDocLine();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          line = line.replaceAll(\"^\\\\s+|\\\\s+$\", \"\");\n        }\n\n        builder.append(line);\n        token = next();\n    }\n  } while (true);\n}"
    ]
  }
}