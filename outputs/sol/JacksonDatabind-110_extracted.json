{
  "JacksonDatabind-110": {
    "The root cause of the bug is that the `findForCollection` function is not correctly handling the deserialization of unmodifiable lists. Specifically, it is trying to create an instance of `java.util.Collections$UnmodifiableList` using a default no-arguments constructor, which does not exist. This is because `java.util.Collections$UnmodifiableList` is an inner class that requires an instance of the outer class `java.util.Collections` to be created.": [
      "Use a Custom Deserializer\nWe can create a custom deserializer for unmodifiable lists that uses the `java.util.Collections.unmodifiableList` method to create an instance of `java.util.Collections$UnmodifiableList`. This would involve creating a new class that implements the `JsonDeserializer` interface and overriding the `deserialize` method to create an instance of `java.util.Collections$UnmodifiableList`.",
      "Modify the findForCollection Function\nWe can modify the `findForCollection` function to handle the deserialization of unmodifiable lists differently. For example, we can check if the type is an instance of `java.util.Collections$UnmodifiableList` and if so, use a different approach to deserialize it. This could involve using the `java.util.Collections.unmodifiableList` method to create an instance of `java.util.Collections$UnmodifiableList`.",
      "Use a Different Converter\nWe can use a different converter to deserialize unmodifiable lists. For example, we can use the `JavaUtilCollectionsConverter` class to convert the unmodifiable list to a modifiable list, and then use the `StdDelegatingDeserializer` class to deserialize the modifiable list.\n\nHere is an example of how the custom deserializer could be implemented:\n\n```java\npublic class UnmodifiableListDeserializer extends JsonDeserializer<List<?>> {\n    @Override\n    public List<?> deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        // Create an instance of java.util.Collections$UnmodifiableList\n        List<?> list = java.util.Collections.unmodifiableList(new ArrayList<>());\n        // Deserialize the list\n        JsonToken token = p.getCurrentToken();\n        if (token == JsonToken.START_ARRAY) {\n            while (p.nextToken() != JsonToken.END_ARRAY) {\n                list.add(p.getCurrentValue());\n            }\n        }\n        return list;\n    }\n}\n```\n\nAnd here is an example of how the `findForCollection` function could be modified:\n\n```java\npublic static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        JavaUtilCollectionsConverter conv;\n\n        // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...\n        if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n            conv = converter(TYPE_AS_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {\n            conv = converter(TYPE_SINGLETON_LIST, type, List.class);\n        } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n            conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n        // [databind#2265]: we may have another impl type for unmodifiable Lists, check both\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {\n            // Use a different approach to deserialize unmodifiable lists\n            conv = new UnmodifiableListDeserializer();\n        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n            conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n        } else {\n            return null;\n        }\n        return new StdDelegatingDeserializer<Object>(conv);\n    }\n```"
    ]
  }
}