{
  "Closure-129": {
    "The root cause of the bug is the incorrect annotation of the call as a 'free' call when it is actually a call on a newly created object. This is due to the fact that the function annotateCalls does not correctly handle the case where the call is on a newly created object, and incorrectly sets the FREE_CALL property to true.": [
      "Check for New Expression\nOne possible fix is to add a check for the NEW expression in the annotateCalls function. If the call is on a newly created object, we should not set the FREE_CALL property to true. We can do this by adding a conditional statement to check if the first child of the call node is a NEW expression. The modified code would be:\n```java\nprivate void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n\n  // Keep track of of the \"this\" context of a call.  A call without an\n  // explicit \"this\" is a free call.\n  Node first = n.getFirstChild();\n\n  // ignore cast nodes.\n\n  if (!NodeUtil.isGet(first) && !(first instanceof New)) {\n    n.putBooleanProp(Node.FREE_CALL, true);\n  }\n\n  // Keep track of the context in which eval is called. It is important\n  // to distinguish between \"(0, eval)()\" and \"eval()\".\n  if (first.isName() &&\n      \"eval\".equals(first.getString())) {\n    first.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}\n```",
      "Check for Get Property on New Object\nAnother possible fix is to add a check for the GETPROP expression on a newly created object in the annotateCalls function. If the call is on a property of a newly created object, we should not set the FREE_CALL property to true. We can do this by adding a conditional statement to check if the first child of the call node is a NEW expression and the second child is a GETPROP expression. The modified code would be:\n```java\nprivate void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n\n  // Keep track of of the \"this\" context of a call.  A call without an\n  // explicit \"this\" is a free call.\n  Node first = n.getFirstChild();\n\n  // ignore cast nodes.\n\n  if (!NodeUtil.isGet(first) && !(first instanceof New) && !(first instanceof New && n.getChildCount() > 1 && n.getChildAtIndex(1) instanceof GetProp)) {\n    n.putBooleanProp(Node.FREE_CALL, true);\n  }\n\n  // Keep track of the context in which eval is called. It is important\n  // to distinguish between \"(0, eval)()\" and \"eval()\".\n  if (first.isName() &&\n      \"eval\".equals(first.getString())) {\n    first.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}\n```",
      "Check for Call on New Object with Specific Property\nA third possible fix is to add a check for the specific case where the call is on a newly created object with a specific property in the annotateCalls function. We can do this by adding a conditional statement to check if the first child of the call node is a NEW expression, the second child is a GETPROP expression, and the property name is not \"eval\". The modified code would be:\n```java\nprivate void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n\n  // Keep track of of the \"this\" context of a call.  A call without an\n  // explicit \"this\" is a free call.\n  Node first = n.getFirstChild();\n\n  // ignore cast nodes.\n\n  if (!NodeUtil.isGet(first) && !(first instanceof New && n.getChildCount() > 1 && n.getChildAtIndex(1) instanceof GetProp && !((GetProp)n.getChildAtIndex(1)).getString().equals(\"eval\"))) {\n    n.putBooleanProp(Node.FREE_CALL, true);\n  }\n\n  // Keep track of the context in which eval is called. It is important\n  // to distinguish between \"(0, eval)()\" and \"eval()\".\n  if (first.isName() &&\n      \"eval\".equals(first.getString())) {\n    first.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}\n```"
    ]
  }
}