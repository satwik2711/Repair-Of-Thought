{
  "Jsoup-2": {
    "The issue lies in the way the function handles script tags with text content. When a script tag is encountered, the function chomps to the end tag and adds the content as a text node. However, it does not correctly handle the case where there is text after the script tag. The function incorrectly appends the text after the script tag to the script tag itself, instead of appending it to the parent element.": [
      "Correctly Handle Text After Script Tag\nOne possible fix is to add a check after parsing the script tag to see if there is any remaining text in the input queue. If there is, we can append it to the parent element instead of the script tag. This can be done by adding a conditional statement to check if the input queue is not empty after parsing the script tag, and if so, append the remaining text to the parent element.\n\n```java\n// pc data only tags (textarea, script): chomp to end tag, add content as text node\nif (tag.isData()) {\n    String data = tq.chompTo(\"</\" + tagName);\n    tq.chompTo(\">\");\n\n    Node dataNode;\n    if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n        dataNode = TextNode.createFromEncoded(data, baseUri);\n    else\n        dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n    child.appendChild(dataNode);   \n\n    // Check if there is any remaining text in the input queue\n    if (!tq.isEmpty()) {\n        String remainingText = tq.consumeTo(\"<\");\n        Node remainingTextNode = new TextNode(remainingText, baseUri);\n        child.getParentNode().appendChild(remainingTextNode);\n    }\n}\n```",
      "Use a Separate Function to Handle Script Tags\nAnother possible fix is to use a separate function to handle script tags. This function can be responsible for parsing the script tag and its content, and appending the content to the correct element. This approach can make the code more modular and easier to maintain.\n\n```java\nprivate void parseScriptTag() {\n    String data = tq.chompTo(\"</\" + tagName);\n    tq.chompTo(\">\");\n\n    Node dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n    child.appendChild(dataNode);   \n\n    // Check if there is any remaining text in the input queue\n    if (!tq.isEmpty()) {\n        String remainingText = tq.consumeTo(\"<\");\n        Node remainingTextNode = new TextNode(remainingText, baseUri);\n        child.getParentNode().appendChild(remainingTextNode);\n    }\n}\n```",
      "Modify the addChildToParent Function\nA third possible fix is to modify the `addChildToParent` function to correctly handle the case where a script tag has text content. This function can be modified to check if the child element is a script tag, and if so, append the text content to the parent element instead of the script tag.\n\n```java\nprivate void addChildToParent(Element child, boolean isEmptyElement) {\n    if (child.tagName().equals(\"script\")) {\n        // Check if there is any remaining text in the input queue\n        if (!tq.isEmpty()) {\n            String remainingText = tq.consumeTo(\"<\");\n            Node remainingTextNode = new TextNode(remainingText, baseUri);\n            child.getParentNode().appendChild(remainingTextNode);\n        }\n    }\n    // ... rest of the function remains the same\n}\n```"
    ]
  }
}